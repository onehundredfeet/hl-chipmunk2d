
// ---------------------------------------------------------------------------------------------------------
// chipmunk_types.h
//----------------------------------------------------------------------------------------------------------
typedef cpFloat double;
typedef cpBool uchar;
typedef cpDataPointer VoidPtr;
typedef cpGroup int64;
typedef cpBitmask uint;


// ---------------------------------------------------------------------------------------------------------
// cpVect.h
//----------------------------------------------------------------------------------------------------------
interface cpVect
{
	attribute cpFloat x;
    attribute cpFloat y;
	
	void cpVect();

	[Static,Value] cpVect cpv([Const] cpFloat x, [Const] cpFloat y);

	[Static] cpBool cpveql([Const,Deref] cpVect v1, [Const,Deref] cpVect v2);

	[Static,Value] cpVect cpvadd([Const,Deref] cpVect v1, [Const,Deref] cpVect v2);

	[Static,Value] cpVect cpvsub([Const,Deref] cpVect v1, [Const,Deref] cpVect v2);

	[Static,Value] cpVect cpvneg([Const,Deref] cpVect v);

	[Static,Value] cpVect cpvmult([Const,Deref] cpVect v, [Const] cpFloat s);

	[Static] cpFloat cpvdot([Const,Deref] cpVect v1, [Const,Deref] cpVect v2);

	[Static] cpFloat cpvcross([Const,Deref] cpVect v1, [Const,Deref] cpVect v2);

	[Static,Value] cpVect cpvperp([Const,Deref] cpVect v);

	[Static,Value] cpVect cpvrperp([Const,Deref] cpVect v);

	[Static,Value] cpVect cpvproject([Const,Deref] cpVect v1, [Const,Deref] cpVect v2);

	[Static,Value] cpVect cpvforangle([Const] cpFloat a);

	[Static] cpFloat cpvtoangle([Const,Deref] cpVect v);

	[Static,Value] cpVect cpvrotate([Const,Deref] cpVect v1, [Const,Deref] cpVect v2);

	[Static,Value] cpVect cpvunrotate([Const,Deref] cpVect v1, [Const,Deref] cpVect v2);

	[Static] cpFloat cpvlengthsq([Const,Deref] cpVect v);

	[Static] cpFloat cpvlength([Const,Deref] cpVect v);

	[Static,Value] cpVect cpvlerp([Const,Deref] cpVect v1, [Const,Deref] cpVect v2, [Const] cpFloat t);

	[Static,Value] cpVect cpvnormalize([Const,Deref] cpVect v);

	[Static,Value] cpVect cpvslerp([Const,Deref] cpVect v1, [Const,Deref] cpVect v2, [Const] cpFloat t);
	
	[Static,Value] cpVect cpvslerpconst([Const,Deref] cpVect v1, [Const,Deref] cpVect v2, [Const] cpFloat a);
	
	[Static,Value] cpVect cpvclamp([Const,Deref] cpVect v, [Const] cpFloat len);
	
	[Static,Value] cpVect cpvlerpconst([Deref] cpVect v1, [Deref] cpVect v2, cpFloat d);
	
	[Static] cpFloat cpvdist([Const,Deref] cpVect v1, [Const,Deref] cpVect v2);
	
	[Static] cpFloat cpvdistsq([Const,Deref] cpVect v1, [Const,Deref] cpVect v2);
	
	[Static] cpBool cpvnear([Const,Deref] cpVect v1, [Const,Deref] cpVect v2, [Const] cpFloat dist);
};


// ---------------------------------------------------------------------------------------------------------
// cpTransform.h
//----------------------------------------------------------------------------------------------------------
interface cpTransform 
{
	attribute cpFloat a;
	attribute cpFloat b;
	attribute cpFloat c;
	attribute cpFloat d;
	attribute cpFloat tx; 
	attribute cpFloat ty;

	void cpTransform();

	[Static,Value] cpTransform cpTransformNew(cpFloat a, cpFloat b, cpFloat c, cpFloat d, cpFloat tx, cpFloat ty);

	[Static,Value] cpTransform cpTransformNewTranspose(cpFloat a, cpFloat c, cpFloat tx, cpFloat b, cpFloat d, cpFloat ty);

	[Static,Value] cpTransform cpTransformInverse([Deref] cpTransform t);

	[Static,Value] cpTransform cpTransformMult([Deref] cpTransform t1, [Deref] cpTransform t2);

	[Static,Value] cpVect cpTransformPoint([Deref] cpTransform t, [Deref] cpVect p);

	[Static,Value] cpVect cpTransformVect([Deref] cpTransform t, [Deref] cpVect v);

	[Static,Value] cpBB cpTransformbBB([Deref] cpTransform t, [Deref] cpBB bb);

	[Static,Value] cpTransform cpTransformTranslate([Deref] cpVect translate);

	[Static,Value] cpTransform cpTransformScale(cpFloat scaleX, cpFloat scaleY);

	[Static,Value] cpTransform cpTransformRotate(cpFloat radians);

	[Static,Value] cpTransform cpTransformRigid([Deref] cpVect translate, cpFloat radians);

	[Static,Value] cpTransform cpTransformRigidInverse([Deref] cpTransform t);

	[Static,Value] cpTransform cpTransformWrap([Deref] cpTransform outer, [Deref] cpTransform inner);

	[Static,Value] cpTransform cpTransformWrapInverse([Deref] cpTransform outer, [Deref] cpTransform inner);

	[Static,Value] cpTransform cpTransformOrtho([Deref] cpBB bb);

	[Static,Value] cpTransform cpTransformBoneScale([Deref] cpVect v0, [Deref] cpVect v1);

	[Static,Value] cpTransform cpTransformAxialScale([Deref] cpVect axis, [Deref] cpVect pivot, cpFloat scale);
};



interface cpMat2x2 {
	void cpMat2x2();
	attribute cpFloat a; 
	attribute cpFloat b;
	attribute cpFloat c;
	attribute cpFloat d;
};


// ---------------------------------------------------------------------------------------------------------
// cpBB.h
//----------------------------------------------------------------------------------------------------------
interface cpBB
{
    void cpBB();
    attribute cpFloat l;
    attribute cpFloat b;
    attribute cpFloat r;
    attribute cpFloat t;
	
	[Static,Value] cpBB cpBBNew([Const] cpFloat l, [Const] cpFloat b, [Const] cpFloat r, [Const] cpFloat t);
	[Static,Value] cpBB cpBBNewForExtents([Const,Deref] cpVect c, [Const] cpFloat hw, [Const] cpFloat hh);
	[Static,Value] cpBB cpBBNewForCircle([Const,Deref] cpVect p, [Const] cpFloat r);
	[Static] cpBool cpBBIntersects([Const,Deref] cpBB a, [Const,Deref] cpBB b);
	[Static] cpBool cpBBContainsBB([Const,Deref] cpBB bb, [Const,Deref] cpBB other);
	[Static] cpBool cpBBContainsVect([Const,Deref] cpBB bb, [Const,Deref] cpVect v);
	[Static,Value] cpBB cpBBMerge([Const,Deref] cpBB a, [Const,Deref] cpBB b);
	[Static,Value] cpBB cpBBExpand([Const,Deref] cpBB bb, [Const,Deref] cpVect v);
	[Static,Value] cpVect cpBBCenter([Deref] cpBB bb);
	[Static] cpFloat cpBBArea([Deref] cpBB bb);
	[Static] cpFloat cpBBMergedArea([Deref] cpBB a, [Deref] cpBB b);
	[Static] cpFloat cpBBSegmentQuery([Deref] cpBB bb, [Deref] cpVect a, [Deref] cpVect b);
	[Static] cpBool cpBBIntersectsSegment([Deref] cpBB bb, [Deref] cpVect a, [Deref] cpVect b);
	[Static,Value] cpVect cpBBClampVect([Const,Deref] cpBB bb, [Const,Deref] cpVect v);
	[Static,Value] cpVect cpBBWrapVect([Const,Deref] cpBB bb, [Const,Deref] cpVect v);
	[Static,Value] cpBB cpBBOffset([Const,Deref] cpBB bb, [Const,Deref] cpVect v);
};


// ---------------------------------------------------------------------------------------------------------
// cpBody.h
//----------------------------------------------------------------------------------------------------------
// enum cpBodyTypeHL {
// 	"CP_BODY_TYPE_DYNAMIC",
// 	"CP_BODY_TYPE_KINEMATIC",
// 	"CP_BODY_TYPE_STATIC"
// };

[Internal="cpBody"]	
interface cpBody {
	
	void cpBody();

	[Static] cpBody cpBodyAlloc();

	[Static] cpBody cpBodyInit(cpBody body, cpFloat mass, cpFloat moment);

	[Static] cpBody cpBodyNew(cpFloat mass, cpFloat moment);

	[Static] cpBody cpBodyNewKinematic();

	[Static] cpBody cpBodyNewStatic();

	[CObject] void cpBodyDestroy();
	
	[CObject] void cpBodyFree();

	[CObject] void cpBodyActivate();

	//[CObject] void cpBodyActivateStatic( cpShape filter);

	[CObject] void cpBodySleep();

	[CObject] void cpBodySleepWithGroup(cpBody group);

	[CObject] cpBool cpBodyIsSleeping();

	//[CObject] cpBodyType cpBodyGetType();

	//[CObject] void cpBodySetType(cpBodyType type);

	// [CObject] cpSpace cpBodyGetSpace();

	[CObject] cpFloat cpBodyGetMass();

	[CObject] void cpBodySetMass(cpFloat m);

	[CObject] cpFloat cpBodyGetMoment();

	[CObject] void cpBodySetMoment(cpFloat i);

	[CObject,Value] cpVect cpBodyGetPosition();

	[CObject] void cpBodySetPosition([Deref] cpVect pos);

	[CObject,Value] cpVect cpBodyGetCenterOfGravity();
	
	[CObject] void cpBodySetCenterOfGravity([Deref] cpVect cog);

	[CObject,Value] cpVect cpBodyGetVelocity();

	[CObject] void cpBodySetVelocity([Deref] cpVect velocity);

	[CObject,Value] cpVect cpBodyGetForce();

	[CObject] void cpBodySetForce([Deref] cpVect force);

	[CObject] cpFloat cpBodyGetAngle();

	[CObject] void cpBodySetAngle(cpFloat a);

	[CObject] cpFloat cpBodyGetAngularVelocity();

	[CObject] void cpBodySetAngularVelocity(cpFloat angularVelocity);

	[CObject] cpFloat cpBodyGetTorque();

	[CObject] void cpBodySetTorque(cpFloat torque);

	[CObject,Value] cpVect cpBodyGetRotation();

	//[CObject] cpDataPointer cpBodyGetUserData();

	//[CObject] void cpBodySetUserData(cpDataPointer userData);

	// [CObject] void cpBodySetVelocityUpdateFunc(cpBodyVelocityFunc velocityFunc); // TODO

	// [CObject] void cpBodySetPositionUpdateFunc(cpBodyPositionFunc positionFunc); // TODO

	[CObject] void cpBodyUpdateVelocity([Deref] cpVect gravity, cpFloat damping, cpFloat dt);
	
	[CObject] void cpBodyUpdatePosition(cpFloat dt);

	[CObject,Value] cpVect cpBodyLocalToWorld([Const,Deref] cpVect point);

	[CObject,Value] cpVect cpBodyWorldToLocal([Const,Deref] cpVect point);

	[CObject] void cpBodyApplyForceAtWorldPoint([Deref] cpVect force, [Deref] cpVect point);

	[CObject] void cpBodyApplyForceAtLocalPoint([Deref] cpVect force, [Deref] cpVect point);

	[CObject] void cpBodyApplyImpulseAtWorldPoint([Deref] cpVect impulse, [Deref] cpVect point);
	
	[CObject] void cpBodyApplyImpulseAtLocalPoint([Deref] cpVect impulse, [Deref] cpVect point);

	[CObject,Value] cpVect cpBodyGetVelocityAtWorldPoint([Deref] cpVect point);
	
	[CObject,Value]  cpVect cpBodyGetVelocityAtLocalPoint([Deref] cpVect point);

	[CObject] cpFloat cpBodyKineticEnergy();

	// TODO
	// [CObject] void cpBodyEachShape(cpBodyShapeIteratorFunc func, void *data);

	// [CObject] void cpBodyEachConstraint(cpBodyConstraintIteratorFunc func, void *data);

	// [CObject] void cpBodyEachArbiter(cpBodyArbiterIteratorFunc func, void *data);
};


// ---------------------------------------------------------------------------------------------------------
// cpShape.h
//----------------------------------------------------------------------------------------------------------

interface cpPointQueryInfo 
{
	void cpPointQueryInfo();
	[Const] attribute cpShape shape;
	[Value] attribute cpVect point;
	attribute cpFloat distance;
	[Value] attribute cpVect gradient;
};

interface cpSegmentQueryInfo {
	void cpSegmentQueryInfo();
	[Const] attribute cpShape shape;
	[Value] attribute cpVect point;
	[Value] attribute cpVect normal;
	attribute cpFloat alpha;
};

interface cpShapeFilter {
	void cpShapeFilter();
	attribute int64 group;
	attribute cpBitmask categories;
	attribute cpBitmask mask;
};

interface cpShape
{
	void cpShape();

	[Static,Value] cpShapeFilter cpShapeFilterNew(cpGroup group, cpBitmask categories, cpBitmask mask);

	[CObject] void cpShapeDestroy();

	[CObject] void cpShapeFree();

	[CObject,Value] cpBB cpShapeCacheBB();

	[CObject,Value] cpBB cpShapeUpdate([Deref] cpTransform transform);

	[CObject] cpFloat cpShapePointQuery([Deref] cpVect p, cpPointQueryInfo out);

	[CObject] cpBool cpShapeSegmentQuery([Deref] cpVect a, [Deref] cpVect b, cpFloat radius, cpSegmentQueryInfo info);

	[Static,Value] cpContactPointSet cpShapesCollide([Const] cpShape a, [Const] cpShape b);

	[CObject] cpSpace cpShapeGetSpace();

	[CObject] cpBody cpShapeGetBody();

	[CObject] void cpShapeSetBody(cpBody body);

	[CObject] cpFloat cpShapeGetMass();

	[CObject] void cpShapeSetMass(cpFloat mass);

	[CObject] cpFloat cpShapeGetDensity();

	[CObject] void cpShapeSetDensity(cpFloat density);

	[CObject] cpFloat cpShapeGetMoment();

	[CObject] cpFloat cpShapeGetArea();

	[CObject,Value] cpVect cpShapeGetCenterOfGravity();

	[CObject,Value] cpBB cpShapeGetBB();

	[CObject] cpBool cpShapeGetSensor();

	[CObject] void cpShapeSetSensor(cpBool sensor);

	[CObject] cpFloat cpShapeGetElasticity();

	[CObject] void cpShapeSetElasticity(cpFloat elasticity);

	[CObject] cpFloat cpShapeGetFriction();

	[CObject] void cpShapeSetFriction(cpFloat friction);

	[CObject,Value] cpVect cpShapeGetSurfaceVelocity();

	[CObject] void cpShapeSetSurfaceVelocity([Deref] cpVect surfaceVelocity);

	[CObject] cpDataPointer cpShapeGetUserData();

	[CObject] void cpShapeSetUserData(cpDataPointer userData);

	// [CObject] cpCollisionType cpShapeGetCollisionType();

	// [CObject] void cpShapeSetCollisionType(cpCollisionType collisionType);

	[CObject,Value] cpShapeFilter cpShapeGetFilter();

	[CObject] void cpShapeSetFilter([Deref] cpShapeFilter filter);
};

interface cpCircleShape
{
	[Static] cpCircleShape cpCircleShapeAlloc();
	[Static] cpCircleShape cpCircleShapeInit(cpCircleShape circle, cpBody body, cpFloat radius, [Deref] cpVect offset);
	[Static] cpShape cpCircleShapeNew(cpBody body, cpFloat radius, [Deref] cpVect offset);
	[Static,Value] cpVect cpCircleShapeGetOffset([Const] cpShape shape);
	[Static] cpFloat cpCircleShapeGetRadius([Const] cpShape shape);
};

interface cpSegmentShape
{
	[Static] cpSegmentShape cpSegmentShapeAlloc();

	[Static] cpSegmentShape cpSegmentShapeInit(cpSegmentShape seg, cpBody body, 
				[Deref] cpVect a, [Deref] cpVect b, cpFloat radius);

	[Static] cpShape cpSegmentShapeNew(cpBody body, [Deref] cpVect a, [Deref] cpVect b, cpFloat radius);

	[Static] void cpSegmentShapeSetNeighbors(cpShape shape, [Deref] cpVect prev, [Deref] cpVect next);

	[Static,Value] cpVect cpSegmentShapeGetA([Const] cpShape shape);

	[Static,Value] cpVect cpSegmentShapeGetB([Const] cpShape shape);

	[Static,Value] cpVect cpSegmentShapeGetNormal([Const] cpShape shape);

	[Static] cpFloat cpSegmentShapeGetRadius([Const] cpShape shape);
};

// ---------------------------------------------------------------------------------------------------------
// cpSpace.h
//----------------------------------------------------------------------------------------------------------
interface cpSpace
{
	[Static] cpSpace cpSpaceInit(cpSpace space);

	[Static] cpSpace cpSpaceNew();

	[CObject] void cpSpaceDestroy();

	[CObject] void cpSpaceFree();

	[CObject] int cpSpaceGetIterations();

	[CObject] void cpSpaceSetIterations(int iterations);

	[CObject,Value] cpVect cpSpaceGetGravity();

	[CObject] void cpSpaceSetGravity([Deref] cpVect gravity);

	[CObject] cpFloat cpSpaceGetDamping();

	[CObject] void cpSpaceSetDamping(cpFloat damping);

	[CObject] cpFloat cpSpaceGetIdleSpeedThreshold();

	[CObject] void cpSpaceSetIdleSpeedThreshold(cpFloat idleSpeedThreshold);

	[CObject] cpFloat cpSpaceGetSleepTimeThreshold();

	[CObject] void cpSpaceSetSleepTimeThreshold(cpFloat sleepTimeThreshold);

	[CObject] cpFloat cpSpaceGetCollisionSlop();

	[CObject] void cpSpaceSetCollisionSlop(cpFloat collisionSlop);

	[CObject] cpFloat cpSpaceGetCollisionBias();

	[CObject] void cpSpaceSetCollisionBias(cpFloat collisionBias);

	// [CObject] cpTimestamp cpSpaceGetCollisionPersistence();

	// [CObject] void cpSpaceSetCollisionPersistence(cpTimestamp collisionPersistence);

	[CObject] cpDataPointer cpSpaceGetUserData();

	[CObject] void cpSpaceSetUserData(cpDataPointer userData);

	[CObject] cpBody cpSpaceGetStaticBody();

	[CObject] cpFloat cpSpaceGetCurrentTimeStep();

	[CObject] cpBool cpSpaceIsLocked();

	// [CObject] cpCollisionHandler *cpSpaceAddDefaultCollisionHandler();

	// [CObject] cpCollisionHandler *cpSpaceAddCollisionHandler(cpCollisionType a, cpCollisionType b);

	// [CObject] cpCollisionHandler *cpSpaceAddWildcardHandler(cpCollisionType type);

	[CObject] void cpSpaceAddShapeVoid(cpShape shape); // README. I had to replace the original functions because each call was duplicating the space.

	[CObject] void cpSpaceAddBodyVoid(cpBody body); // README. I had to replace the original functions because each call was duplicating the space.

	[CObject] cpConstraint cpSpaceAddConstraint(cpConstraint constraint);

	[CObject] void cpSpaceRemoveShape(cpShape shape);

	[CObject] void cpSpaceRemoveBody(cpBody body);

	[CObject] void cpSpaceRemoveConstraint(cpConstraint constraint);

	[CObject] cpBool cpSpaceContainsShape(cpShape shape);

	[CObject] cpBool cpSpaceContainsBody(cpBody body);

	[CObject] cpBool cpSpaceContainsConstraint(cpConstraint constraint);

	// [CObject] cpBool cpSpaceAddPostStepCallback(cpPostStepFunc func, void *key, void *data);

	// [CObject] void cpSpacePointQuery(cpVect point, cpFloat maxDistance, cpShapeFilter filter, cpSpacePointQueryFunc func, void *data);

	// [CObject] cpShape cpSpacePointQueryNearest(cpVect point, cpFloat maxDistance, cpShapeFilter filter, cpPointQueryInfo *out);

	// [CObject] void cpSpaceSegmentQuery(cpVect start, cpVect end, cpFloat radius, cpShapeFilter filter, cpSpaceSegmentQueryFunc func, void *data);

	[CObject] cpShape cpSpaceSegmentQueryFirst([Deref] cpVect start, [Deref] cpVect end, cpFloat radius, [Deref] cpShapeFilter filter, cpSegmentQueryInfo out);
	
	[CObject] cpShape cpSpaceSegmentQueryFirstNoFilter([Deref] cpVect start, [Deref] cpVect end, cpFloat radius, cpSegmentQueryInfo out);

	// [CObject] void cpSpaceBBQuery(cpBB bb, cpShapeFilter filter, cpSpaceBBQueryFunc func, void *data);

	// [CObject] cpBool cpSpaceShapeQuery(cpShape shape, cpSpaceShapeQueryFunc func, void *data);

	// [CObject] void cpSpaceEachBody(cpSpaceBodyIteratorFunc func, void *data);

	// [CObject] void cpSpaceEachShape(cpSpaceShapeIteratorFunc func, void *data);

	// [CObject] void cpSpaceEachConstraint(cpSpaceConstraintIteratorFunc func, void *data);

	[CObject] void cpSpaceReindexStatic();

	[CObject] void cpSpaceReindexShape(cpShape shape);

	[CObject] void cpSpaceReindexShapesForBody(cpBody body);

	[CObject] void cpSpaceUseSpatialHash(cpFloat dim, int count);

	[CObject] void cpSpaceStep(cpFloat dt);
};


// ---------------------------------------------------------------------------------------------------------
// cpArbiter.h
//----------------------------------------------------------------------------------------------------------
interface cpContactPointSet {
	
};

interface cpArbiter
{
	[CObject] cpFloat cpArbiterGetRestitution();

	[CObject] void cpArbiterSetRestitution(cpFloat restitution);

	[CObject] cpFloat cpArbiterGetFriction();

	[CObject] void cpArbiterSetFriction(cpFloat friction);

	[CObject,Value] cpVect cpArbiterGetSurfaceVelocity();

	[CObject] void cpArbiterSetSurfaceVelocity([Deref] cpVect vr);

	[CObject] cpDataPointer cpArbiterGetUserData();

	[CObject] void cpArbiterSetUserData(cpDataPointer userData);

	[CObject,Value] cpVect cpArbiterTotalImpulse();

	[CObject] cpFloat cpArbiterTotalKE();

	[CObject] cpBool cpArbiterIgnore();

	// CP_EXPORT void cpArbiterGetShapes(const cpArbiter *arb, cpShape **a, cpShape **b);

	// CP_EXPORT void cpArbiterGetBodies(const cpArbiter *arb, cpBody **a, cpBody **b);

	[CObject,Value] cpContactPointSet cpArbiterGetContactPointSet();

	[CObject] void cpArbiterSetContactPointSet(cpContactPointSet set);

	[CObject] cpBool cpArbiterIsFirstContact();

	[CObject] cpBool cpArbiterIsRemoval();

	[CObject] int cpArbiterGetCount();

	[CObject,Value] cpVect cpArbiterGetNormal();

	[CObject,Value] cpVect cpArbiterGetPointA(int i);

	[CObject,Value] cpVect cpArbiterGetPointB(int i);

	[CObject] cpFloat cpArbiterGetDepth(int i);

	[CObject] cpBool cpArbiterCallWildcardBeginA(cpSpace space);

	[CObject] cpBool cpArbiterCallWildcardBeginB(cpSpace space);

	[CObject] cpBool cpArbiterCallWildcardPreSolveA(cpSpace space);

	[CObject] cpBool cpArbiterCallWildcardPreSolveB(cpSpace space);

	[CObject] void cpArbiterCallWildcardPostSolveA(cpSpace space);

	[CObject] void cpArbiterCallWildcardPostSolveB(cpSpace space);

	[CObject] void cpArbiterCallWildcardSeparateA(cpSpace space);

	[CObject] void cpArbiterCallWildcardSeparateB(cpSpace space);
};


// ---------------------------------------------------------------------------------------------------------
// cpConstraint.h
//----------------------------------------------------------------------------------------------------------
interface cpConstraint
{
	[CObject] void cpConstraintDestroy();

	[CObject] void cpConstraintFree();

	[CObject] cpSpace cpConstraintGetSpace();

	[CObject] cpBody cpConstraintGetBodyA();

	[CObject] cpBody cpConstraintGetBodyB();

	[CObject] cpFloat cpConstraintGetMaxForce();
	
	[CObject] void cpConstraintSetMaxForce(cpFloat maxForce);

	[CObject] cpFloat cpConstraintGetErrorBias();

	[CObject] void cpConstraintSetErrorBias(cpFloat errorBias);

	[CObject] cpFloat cpConstraintGetMaxBias();

	[CObject] void cpConstraintSetMaxBias(cpFloat maxBias);

	[CObject] cpBool cpConstraintGetCollideBodies();

	[CObject] void cpConstraintSetCollideBodies(cpBool collideBodies);

	//[CObject] cpConstraintPreSolveFunc cpConstraintGetPreSolveFunc();

	//[CObject] void cpConstraintSetPreSolveFunc(cpConstraintPreSolveFunc preSolveFunc);

	//[CObject] cpConstraintPostSolveFunc cpConstraintGetPostSolveFunc();

	//[CObject] void cpConstraintSetPostSolveFunc(cpConstraintPostSolveFunc postSolveFunc);

	[CObject] cpDataPointer cpConstraintGetUserData();

	[CObject] void cpConstraintSetUserData(cpDataPointer userData);

	[CObject] cpFloat cpConstraintGetImpulse();
};


// ---------------------------------------------------------------------------------------------------------
// cpDampedRotarySpring.h
//----------------------------------------------------------------------------------------------------------
interface cpDampedRotarySpring
{
	[Static] cpBool cpConstraintIsDampedRotarySpring([Const] cpConstraint constraint);

	[Static] cpDampedRotarySpring cpDampedRotarySpringAlloc();

	[Static] cpDampedRotarySpring cpDampedRotarySpringInit(cpDampedRotarySpring joint, 
			cpBody a, cpBody b, cpFloat restAngle, cpFloat stiffness, cpFloat damping);

	[Static] cpConstraint cpDampedRotarySpringNew(cpBody a, cpBody b, cpFloat restAngle, 
			cpFloat stiffness, cpFloat damping);

	[Static] cpFloat cpDampedRotarySpringGetRestAngle([Const] cpConstraint constraint);

	[Static] void cpDampedRotarySpringSetRestAngle(cpConstraint constraint, cpFloat restAngle);

	[Static] cpFloat cpDampedRotarySpringGetStiffness([Const] cpConstraint constraint);

	[Static] void cpDampedRotarySpringSetStiffness([Const] cpConstraint constraint, cpFloat stiffness);

	[Static] cpFloat cpDampedRotarySpringGetDamping([Const] cpConstraint constraint);

	[Static] void cpDampedRotarySpringSetDamping(cpConstraint constraint, cpFloat damping);

	// [Static] cpDampedRotarySpringTorqueFunc cpDampedRotarySpringGetSpringTorqueFunc(const cpConstraint *constraint);

	//[Static] void cpDampedRotarySpringSetSpringTorqueFunc(cpConstraint *constraint, cpDampedRotarySpringTorqueFunc springTorqueFunc);
};


// ---------------------------------------------------------------------------------------------------------
// cpDampedSpring.h
//----------------------------------------------------------------------------------------------------------
interface cpDampedSpring
{
	[Static] cpBool cpConstraintIsDampedSpring([Const] cpConstraint constraint);

	[Static] cpDampedSpring cpDampedSpringAlloc();

	[Static] cpDampedSpring cpDampedSpringInit(cpDampedSpring joint, cpBody a, cpBody b, 
			[Deref] cpVect anchorA, [Deref] cpVect anchorB, cpFloat restLength, cpFloat stiffness, cpFloat damping);

	[Static] cpConstraint cpDampedSpringNew(cpBody a, cpBody b, [Deref] cpVect anchorA, [Deref] cpVect anchorB, 
			cpFloat restLength, cpFloat stiffness, cpFloat damping);

	[Static,Value] cpVect cpDampedSpringGetAnchorA([Const] cpConstraint constraint);

	[Static] void cpDampedSpringSetAnchorA(cpConstraint constraint, [Deref] cpVect anchorA);

	[Static,Value] cpVect cpDampedSpringGetAnchorB([Const] cpConstraint constraint);

	[Static] void cpDampedSpringSetAnchorB(cpConstraint constraint, [Deref] cpVect anchorB);

	[Static] cpFloat cpDampedSpringGetRestLength([Const] cpConstraint constraint);

	[Static] void cpDampedSpringSetRestLength(cpConstraint constraint, cpFloat restLength);

	[Static] cpFloat cpDampedSpringGetStiffness([Const] cpConstraint constraint);

	[Static] void cpDampedSpringSetStiffness(cpConstraint constraint, cpFloat stiffness);

	[Static] cpFloat cpDampedSpringGetDamping([Const] cpConstraint constraint);

	[Static] void cpDampedSpringSetDamping(cpConstraint constraint, cpFloat damping);

	// [Static] cpDampedSpringForceFunc cpDampedSpringGetSpringForceFunc(const cpConstraint *constraint);

	// [Static] void cpDampedSpringSetSpringForceFunc(cpConstraint *constraint, cpDampedSpringForceFunc springForceFunc);
};


// ---------------------------------------------------------------------------------------------------------
// cpGearJoint.h
//----------------------------------------------------------------------------------------------------------
interface cpGearJoint
{
	[Static] cpBool cpConstraintIsGearJoint([Const]  cpConstraint constraint);

	[Static] cpGearJoint cpGearJointAlloc();

	[Static] cpGearJoint cpGearJointInit(cpGearJoint joint, cpBody a, cpBody b, cpFloat phase, cpFloat ratio);

	[Static] cpConstraint cpGearJointNew(cpBody a, cpBody b, cpFloat phase, cpFloat ratio);

	[Static] cpFloat cpGearJointGetPhase([Const] cpConstraint constraint);

	[Static] void cpGearJointSetPhase(cpConstraint constraint, cpFloat phase);

	[Static] cpFloat cpGearJointGetRatio([Const] cpConstraint constraint);

	[Static] void cpGearJointSetRatio(cpConstraint constraint, cpFloat ratio);
};


// ---------------------------------------------------------------------------------------------------------
// cpSimpleMotor.h
//----------------------------------------------------------------------------------------------------------
interface cpSimpleMotor
{
	[Static] cpBool cpConstraintIsSimpleMotor([Const] cpConstraint constraint);

	[Static] cpSimpleMotor cpSimpleMotorAlloc();

	[Static] cpSimpleMotor cpSimpleMotorInit(cpSimpleMotor joint, cpBody a, cpBody b, cpFloat rate);

	[Static] cpConstraint cpSimpleMotorNew(cpBody a, cpBody b, cpFloat rate);

	[Static] cpFloat cpSimpleMotorGetRate([Const] cpConstraint constraint);

	[Static] void cpSimpleMotorSetRate(cpConstraint constraint, cpFloat rate);
};


// ---------------------------------------------------------------------------------------------------------
// cpGrooveJoint.h
//----------------------------------------------------------------------------------------------------------
interface cpGrooveJoint
{
	[Static] cpBool cpConstraintIsGrooveJoint([Const] cpConstraint constraint);

	[Static] cpGrooveJoint cpGrooveJointAlloc();

	[Static] cpGrooveJoint cpGrooveJointInit(cpGrooveJoint joint, cpBody a, cpBody b, [Deref] cpVect groove_a, 
			[Deref] cpVect groove_b, [Deref] cpVect anchorB);

	[Static] cpConstraint cpGrooveJointNew(cpBody a, cpBody b, [Deref] cpVect groove_a, [Deref] cpVect groove_b, 
			[Deref] cpVect anchorB);

	[Static,Value] cpVect cpGrooveJointGetGrooveA([Const] cpConstraint constraint);

	[Static] void cpGrooveJointSetGrooveA(cpConstraint constraint, [Deref] cpVect grooveA);

	[Static,Value] cpVect cpGrooveJointGetGrooveB([Const] cpConstraint constraint);

	[Static] void cpGrooveJointSetGrooveB(cpConstraint constraint, [Deref] cpVect grooveB);

	[Static,Value] cpVect cpGrooveJointGetAnchorB([Const] cpConstraint constraint);

	[Static] void cpGrooveJointSetAnchorB(cpConstraint constraint, [Deref] cpVect anchorB);
};


// ---------------------------------------------------------------------------------------------------------
// cpHastySpace.h
//----------------------------------------------------------------------------------------------------------
interface cpHastySpace
{
	[Static] cpSpace cpHastySpaceNew();
	[Static] void cpHastySpaceFree(cpSpace space);
	[Static] void cpHastySpaceSetThreads(cpSpace space, uint threads);
	[Static] uint cpHastySpaceGetThreads(cpSpace space);
	[Static] void cpHastySpaceStep(cpSpace space, cpFloat dt);
};


// ---------------------------------------------------------------------------------------------------------
// cpHastySpace.h
//----------------------------------------------------------------------------------------------------------
interface cpPinJoint
{	
	[Static] cpBool cpConstraintIsPinJoint([Const] cpConstraint constraint);

	[Static] cpPinJoint cpPinJointAlloc();

	[Static] cpPinJoint cpPinJointInit(cpPinJoint joint, cpBody a, cpBody b, 
				[Deref] cpVect anchorA, [Deref] cpVect anchorB);

	[Static] cpConstraint cpPinJointNew(cpBody a, cpBody b, [Deref] cpVect anchorA, [Deref] cpVect anchorB);

	[Static,Value] cpVect cpPinJointGetAnchorA([Const] cpConstraint constraint);

	[Static] void cpPinJointSetAnchorA(cpConstraint constraint, [Deref] cpVect anchorA);

	[Static,Value] cpVect cpPinJointGetAnchorB([Const] cpConstraint constraint);

	[Static] void cpPinJointSetAnchorB(cpConstraint constraint, [Deref] cpVect anchorB);

	[Static] cpFloat cpPinJointGetDist([Const] cpConstraint constraint);

	[Static] void cpPinJointSetDist(cpConstraint constraint, cpFloat dist);
};


// ---------------------------------------------------------------------------------------------------------
// cpPivotJoint.h
//----------------------------------------------------------------------------------------------------------
interface cpPivotJoint
{
	[Static] cpBool cpConstraintIsPivotJoint([Const] cpConstraint constraint);

	[Static] cpPivotJoint cpPivotJointAlloc();

	[Static] cpPivotJoint cpPivotJointInit(cpPivotJoint joint, cpBody a, cpBody b, [Deref] cpVect anchorA, [Deref] cpVect anchorB);

	[Static] cpConstraint cpPivotJointNew(cpBody a, cpBody b, [Deref] cpVect pivot);

	[Static] cpConstraint cpPivotJointNew2(cpBody a, cpBody b, [Deref] cpVect anchorA, [Deref] cpVect anchorB);

	[Static,Value] cpVect cpPivotJointGetAnchorA([Const] cpConstraint constraint);

	[Static] void cpPivotJointSetAnchorA(cpConstraint constraint, [Deref] cpVect anchorA);

	[Static,Value] cpVect cpPivotJointGetAnchorB([Const] cpConstraint constraint);

	[Static] void cpPivotJointSetAnchorB(cpConstraint constraint, [Deref] cpVect anchorB);
};


// ---------------------------------------------------------------------------------------------------------
// cpPolyline.h
//----------------------------------------------------------------------------------------------------------
interface cpPolyline
{
	[Static] void cpPolylineFree(cpPolyline line);

	[Static] cpBool cpPolylineIsClosed(cpPolyline line);

	[Static] cpPolyline cpPolylineSimplifyCurves(cpPolyline line, cpFloat tol);

	[Static] cpPolyline cpPolylineSimplifyVertexes(cpPolyline line, cpFloat tol);

	[Static] cpPolyline cpPolylineToConvexHull(cpPolyline line, cpFloat tol);
};

interface cpPolylineSet
{
	[Static] cpPolylineSet cpPolylineSetAlloc();

	[Static] cpPolylineSet cpPolylineSetInit(cpPolylineSet set);

	[Static] cpPolylineSet cpPolylineSetNew();

	[Static] void cpPolylineSetDestroy(cpPolylineSet set, cpBool freePolylines);

	[Static] void cpPolylineSetFree(cpPolylineSet set, cpBool freePolylines);

	[Static] void cpPolylineSetCollectSegment([Deref] cpVect v0, [Deref] cpVect v1, cpPolylineSet lines);

	[Static] cpPolylineSet cpPolylineConvexDecomposition(cpPolyline line, cpFloat tol);
};


// ---------------------------------------------------------------------------------------------------------
// cpPolyShape.h
//----------------------------------------------------------------------------------------------------------
interface cpPolyShape
{
	[Static] cpPolyShape cpPolyShapeAlloc();

	[Static] cpPolyShape cpPolyShapeInit(cpPolyShape poly, cpBody body, int count, 
				[Const,Cast="cpVect*"] double[] verts, [Deref] cpTransform transform, cpFloat radius);

	[Static] cpPolyShape cpPolyShapeInitRaw(cpPolyShape poly, cpBody body, int count, [Const,Cast="cpVect*"] double[] verts, cpFloat radius);

	[Static] cpShape cpPolyShapeNew(cpBody body, int count, [Const,Cast="cpVect*"] double[] verts, [Deref] cpTransform transform, cpFloat radius);

	[Static] cpShape cpPolyShapeNewRaw(cpBody body, int count, [Const,Cast="cpVect*"] double[] verts, cpFloat radius);

	[Static] cpPolyShape cpBoxShapeInit(cpPolyShape poly, cpBody body, cpFloat width, cpFloat height, cpFloat radius);

	[Static] cpPolyShape cpBoxShapeInit2(cpPolyShape poly, cpBody body, [Deref] cpBB box, cpFloat radius);

	[Static] cpShape cpBoxShapeNew(cpBody body, cpFloat width, cpFloat height, cpFloat radius);

	[Static] cpShape cpBoxShapeNew2(cpBody body, [Deref] cpBB box, cpFloat radius);

	[Static] int cpPolyShapeGetCount([Const] cpShape shape);

	[Static,Value] cpVect cpPolyShapeGetVert([Const] cpShape shape, int index);

	[Static] cpFloat cpPolyShapeGetRadius([Const] cpShape shape);
};


// ---------------------------------------------------------------------------------------------------------
// cpRatchetJoint.h
//----------------------------------------------------------------------------------------------------------
interface cpRatchetJoint
{
	[Static] cpBool cpConstraintIsRatchetJoint([Const] cpConstraint constraint);

	[Static] cpRatchetJoint cpRatchetJointAlloc();

	[Static] cpRatchetJoint cpRatchetJointInit(cpRatchetJoint joint, cpBody a, cpBody b, cpFloat phase, cpFloat ratchet);

	[Static] cpConstraint cpRatchetJointNew(cpBody a, cpBody b, cpFloat phase, cpFloat ratchet);

	[Static] cpFloat cpRatchetJointGetAngle([Const] cpConstraint constraint);

	[Static] void cpRatchetJointSetAngle(cpConstraint constraint, cpFloat angle);

	[Static] cpFloat cpRatchetJointGetPhase([Const] cpConstraint constraint);

	[Static] void cpRatchetJointSetPhase(cpConstraint constraint, cpFloat phase);

	[Static] cpFloat cpRatchetJointGetRatchet([Const] cpConstraint constraint);

	[Static] void cpRatchetJointSetRatchet(cpConstraint constraint, cpFloat ratchet);
};


// ---------------------------------------------------------------------------------------------------------
// cpRotaryLimitJoint
//----------------------------------------------------------------------------------------------------------
interface cpRotaryLimitJoint
{
	[Static] cpBool cpConstraintIsRotaryLimitJoint([Const] cpConstraint constraint);

	[Static] cpRotaryLimitJoint cpRotaryLimitJointAlloc();

	[Static] cpRotaryLimitJoint cpRotaryLimitJointInit(cpRotaryLimitJoint joint, cpBody a, cpBody b, cpFloat min, cpFloat max);
	
	[Static] cpConstraint cpRotaryLimitJointNew(cpBody a, cpBody b, cpFloat min, cpFloat max);

	[Static] cpFloat cpRotaryLimitJointGetMin([Const] cpConstraint constraint);

	[Static] void cpRotaryLimitJointSetMin(cpConstraint constraint, cpFloat min);

	[Static] cpFloat cpRotaryLimitJointGetMax([Const] cpConstraint constraint);

	[Static] void cpRotaryLimitJointSetMax(cpConstraint constraint, cpFloat max);
};


// ---------------------------------------------------------------------------------------------------------
// cpSlideJoint
//----------------------------------------------------------------------------------------------------------
interface cpSlideJoint
{
	[Static] cpBool cpConstraintIsSlideJoint([Const] cpConstraint constraint);

	[Static] cpSlideJoint cpSlideJointAlloc();

	[Static] cpSlideJoint cpSlideJointInit(cpSlideJoint joint, cpBody a, cpBody b, 
				[Deref] cpVect anchorA, [Deref] cpVect anchorB, cpFloat min, cpFloat max);

	[Static] cpConstraint cpSlideJointNew(cpBody a, cpBody b, [Deref] cpVect anchorA, [Deref] cpVect anchorB, 
				cpFloat min, cpFloat max);

	[Static,Value] cpVect cpSlideJointGetAnchorA([Const] cpConstraint constraint);

	[Static] void cpSlideJointSetAnchorA(cpConstraint constraint, [Deref] cpVect anchorA);

	[Static,Value] cpVect cpSlideJointGetAnchorB([Const] cpConstraint constraint);

	[Static] void cpSlideJointSetAnchorB(cpConstraint constraint, [Deref] cpVect anchorB);

	[Static] cpFloat cpSlideJointGetMin([Const] cpConstraint constraint);

	[Static] void cpSlideJointSetMin(cpConstraint constraint, cpFloat min);

	[Static] cpFloat cpSlideJointGetMax([Const] cpConstraint constraint);

	[Static] void cpSlideJointSetMax(cpConstraint constraint, cpFloat max);
};


// ---------------------------------------------------------------------------------------------------------
// cpSpaceHash.c
//----------------------------------------------------------------------------------------------------------
interface cpSpaceHash {};


// ---------------------------------------------------------------------------------------------------------
// cpBBTree.c
//----------------------------------------------------------------------------------------------------------
interface cpBBTree {};


// ---------------------------------------------------------------------------------------------------------
// cpSpatialIndex.h
//----------------------------------------------------------------------------------------------------------
typedef cpHashValue uint;

interface cpSpatialIndexClass {};

interface cpSpatialIndex
{
	[Static] cpSpaceHash cpSpaceHashAlloc();

// CP_EXPORT cpSpatialIndex* cpSpaceHashInit(cpSpaceHash *hash, cpFloat celldim, int numcells, cpSpatialIndexBBFunc bbfunc, cpSpatialIndex *staticIndex);

// CP_EXPORT cpSpatialIndex* cpSpaceHashNew(cpFloat celldim, int cells, cpSpatialIndexBBFunc bbfunc, cpSpatialIndex *staticIndex);

	[Static] void cpSpaceHashResize(cpSpaceHash hash, cpFloat celldim, int numcells);

	[Static] cpBBTree cpBBTreeAlloc();

// CP_EXPORT cpSpatialIndex* cpBBTreeInit(cpBBTree *tree, cpSpatialIndexBBFunc bbfunc, cpSpatialIndex *staticIndex);

// CP_EXPORT cpSpatialIndex* cpBBTreeNew(cpSpatialIndexBBFunc bbfunc, cpSpatialIndex *staticIndex);

	[CObject] void cpBBTreeOptimize();

// CP_EXPORT void cpBBTreeSetVelocityFunc(cpSpatialIndex *index, cpBBTreeVelocityFunc func);

	// [Static] cpSweep1D cpSweep1DAlloc();

// CP_EXPORT cpSpatialIndex* cpSweep1DInit(cpSweep1D *sweep, cpSpatialIndexBBFunc bbfunc, cpSpatialIndex *staticIndex);

// CP_EXPORT cpSpatialIndex* cpSweep1DNew(cpSpatialIndexBBFunc bbfunc, cpSpatialIndex *staticIndex);

	[CObject] void cpSpatialIndexFree();

	// [Static] void cpSpatialIndexCollideStatic(cpSpatialIndex dynamicIndex, cpSpatialIndex staticIndex, 
	// 		cpSpatialIndexQueryFunc func, VoidPtr data);

	[CObject] void cpSpatialIndexDestroy();

	[CObject] int cpSpatialIndexCount();

	// [CObject] void cpSpatialIndexEach(cpSpatialIndexIteratorFunc func, VoidPtr data)

	[CObject] cpBool cpSpatialIndexContains(VoidPtr obj, cpHashValue hashid);

	[CObject] void cpSpatialIndexInsert(VoidPtr obj, cpHashValue hashid);

	[CObject] void cpSpatialIndexRemove(VoidPtr obj, cpHashValue hashid);

	[CObject] void cpSpatialIndexReindex();

	[CObject] void cpSpatialIndexReindexObject(VoidPtr obj, cpHashValue hashid);

// static inline void cpSpatialIndexQuery(cpSpatialIndex *index, void *obj, cpBB bb, 
				// cpSpatialIndexQueryFunc func, void *data)

// static inline void cpSpatialIndexSegmentQuery(cpSpatialIndex *index, void *obj, cpVect a, cpVect b, 
				// cpFloat t_exit, cpSpatialIndexSegmentQueryFunc func, void *data)

// static inline void cpSpatialIndexReindexQuery(cpSpatialIndex *index, cpSpatialIndexQueryFunc func, void *data)
};


// ---------------------------------------------------------------------------------------------------------
// chipmunk.h + cpRobust.h
//----------------------------------------------------------------------------------------------------------
interface Chipmunk2D 
{
	[Static] cpFloat cpMomentForCircle(cpFloat m, cpFloat r1, cpFloat r2, [Deref] cpVect offset);

	[Static] cpFloat cpAreaForCircle(cpFloat r1, cpFloat r2);
	
	[Static] cpFloat cpMomentForSegment(cpFloat m, [Deref,Cast="cpVect*"] cpVect a, [Deref] cpVect b, cpFloat radius);
	
	[Static] cpFloat cpMomentForPoly( cpFloat m, int count, [Const,Cast="cpVect*"] double[] verts, 
							[Deref] cpVect offset, cpFloat radius);

	[Static] cpFloat cpAreaForSegment([Deref] cpVect a, [Deref] cpVect b, cpFloat radius);

	[Static] cpFloat cpAreaForPoly([Const] int count, [Const,Cast="cpVect*"] double[] verts, cpFloat radius);

	[Static,Value] cpVect cpCentroidForPoly([Const] int count, [Cast="cpVect*"] double[] verts);

	[Static] cpFloat cpMomentForBox(cpFloat m, cpFloat width, cpFloat height);

	[Static] cpFloat cpMomentForBox2(cpFloat m, [Deref] cpBB box);

	[Static] int cpConvexHull(int count,  [Const,Cast="cpVect*"] double[] verts, 
							[Cast="cpVect*"] double[] result, int[] first, cpFloat tol);

	[Static,Value] cpVect cpClosetPointOnSegment( [Deref] cpVect p, 
							 [Deref] cpVect a, [Deref] cpVect b);

	// cpRobust.h
	[Static] cpBool cpCheckPointGreater([Const,Deref] cpVect a, [Const,Deref] cpVect b, [Const,Deref] cpVect c);

	[Static] cpBool cpCheckAxis([Deref] cpVect v0, [Deref] cpVect v1, [Deref] cpVect p, [Deref] cpVect n);
};
