
// ---------------------------------------------------------------------------------------------------------
// chipmunk_types.h
//----------------------------------------------------------------------------------------------------------
typedef cpFloat double;
typedef cpBool uchar;
typedef cpDataPointer VoidPtr;
typedef cpGroup int64;
typedef cpBitmask uint;
typedef pVect VoidPtr;

// ---------------------------------------------------------------------------------------------------------
// Vect.h
//----------------------------------------------------------------------------------------------------------
[Internal="cpVect"]
interface Vect
{	
	[Static, Internal="cpVect_x"] cpFloat x([Const,Get="Ptr2cpVect"] pVect v1);
	[Static, Internal="cpVect_y"] cpFloat y([Const,Get="Ptr2cpVect"] pVect v1);

	[Static, Get="cpVect2Ptr"] pVect cpv([Const] cpFloat x, [Const] cpFloat y);

	[Static] cpBool cpveql([Const,Get="Ptr2cpVect"] pVect v1, [Const,Get="Ptr2cpVect"] pVect v2);

	[Static, Get="cpVect2Ptr"] pVect cpvadd([Const,Get="Ptr2cpVect"] pVect v1, [Const,Get="Ptr2cpVect"] pVect v2);

	[Static, Get="cpVect2Ptr"] pVect cpvsub([Const,Get="Ptr2cpVect"] pVect v1, [Const,Get="Ptr2cpVect"] pVect v2);

	[Static, Get="cpVect2Ptr"] pVect cpvneg([Const,Get="Ptr2cpVect"] pVect v);

	[Static, Get="cpVect2Ptr"] pVect cpvmult([Const,Get="Ptr2cpVect"] pVect v, [Const] cpFloat s);

	[Static] cpFloat cpvdot([Const,Get="Ptr2cpVect"] pVect v1, [Const,Get="Ptr2cpVect"] pVect v2);

	[Static] cpFloat cpvcross([Const,Get="Ptr2cpVect"] pVect v1, [Const,Get="Ptr2cpVect"] pVect v2);

	[Static, Get="cpVect2Ptr"] pVect cpvperp([Const,Get="Ptr2cpVect"] pVect v);

	[Static, Get="cpVect2Ptr"] pVect cpvrperp([Const,Get="Ptr2cpVect"] pVect v);

	[Static, Get="cpVect2Ptr"] pVect cpvproject([Const,Get="Ptr2cpVect"] pVect v1, [Const,Get="Ptr2cpVect"] pVect v2);

	[Static, Get="cpVect2Ptr"] pVect cpvforangle([Const] cpFloat a);

	[Static] cpFloat cpvtoangle([Const,Get="Ptr2cpVect"] pVect v);

	[Static, Get="cpVect2Ptr"] pVect cpvrotate([Const,Get="Ptr2cpVect"] pVect v1, [Const,Get="Ptr2cpVect"] pVect v2);

	[Static, Get="cpVect2Ptr"] pVect cpvunrotate([Const,Get="Ptr2cpVect"] pVect v1, [Const,Get="Ptr2cpVect"] pVect v2);

	[Static] cpFloat cpvlengthsq([Const,Get="Ptr2cpVect"] pVect v);

	[Static] cpFloat cpvlength([Const,Get="Ptr2cpVect"] pVect v);

	[Static, Get="cpVect2Ptr"] pVect cpvlerp([Const,Get="Ptr2cpVect"] pVect v1, [Const,Get="Ptr2cpVect"] pVect v2, [Const] cpFloat t);

	[Static, Get="cpVect2Ptr"] pVect cpvnormalize([Const,Get="Ptr2cpVect"] pVect v);

	[Static, Get="cpVect2Ptr"] pVect cpvslerp([Const,Get="Ptr2cpVect"] pVect v1, [Const,Get="Ptr2cpVect"] pVect v2, [Const] cpFloat t);
	
	[Static, Get="cpVect2Ptr"] pVect cpvslerpconst([Const,Get="Ptr2cpVect"] pVect v1, [Const,Get="Ptr2cpVect"] pVect v2, [Const] cpFloat a);
	
	[Static, Get="cpVect2Ptr"] pVect cpvclamp([Const,Get="Ptr2cpVect"] pVect v, [Const] cpFloat len);
	
	[Static, Get="cpVect2Ptr"] pVect cpvlerpconst([Get="Ptr2cpVect"] pVect v1, [Get="Ptr2cpVect"] pVect v2, cpFloat d);
	
	[Static] cpFloat cpvdist([Const,Get="Ptr2cpVect"] pVect v1, [Const,Get="Ptr2cpVect"] pVect v2);
	
	[Static] cpFloat cpvdistsq([Const,Get="Ptr2cpVect"] pVect v1, [Const,Get="Ptr2cpVect"] pVect v2);
	
	[Static] cpBool cpvnear([Const,Get="Ptr2cpVect"] pVect v1, [Const,Get="Ptr2cpVect"] pVect v2, [Const] cpFloat dist);
};


// ---------------------------------------------------------------------------------------------------------
// cpTransform.h
//----------------------------------------------------------------------------------------------------------
interface cpTransform 
{
	attribute cpFloat a;
	attribute cpFloat b;
	attribute cpFloat c;
	attribute cpFloat d;
	attribute cpFloat tx; 
	attribute cpFloat ty;

	void cpTransform();

	[Static,Value] cpTransform cpTransformNew(cpFloat a, cpFloat b, cpFloat c, cpFloat d, cpFloat tx, cpFloat ty);

	[Static,Value] cpTransform cpTransformNewTranspose(cpFloat a, cpFloat c, cpFloat tx, cpFloat b, cpFloat d, cpFloat ty);

	[Static,Value] cpTransform cpTransformInverse([Deref] cpTransform t);

	[Static,Value] cpTransform cpTransformMult([Deref] cpTransform t1, [Deref] cpTransform t2);

	[Static,Get="cpVect2Ptr"] pVect cpTransformPoint([Deref] cpTransform t, [Get="Ptr2cpVect"] pVect p);

	[Static,Get="cpVect2Ptr"] pVect cpTransformVect([Deref] cpTransform t, [Get="Ptr2cpVect"] pVect v);

	[Static,Value] cpBB cpTransformbBB([Deref] cpTransform t, [Deref] cpBB bb);

	[Static,Value] cpTransform cpTransformTranslate([Get="Ptr2cpVect"] pVect translate);

	[Static,Value] cpTransform cpTransformScale(cpFloat scaleX, cpFloat scaleY);

	[Static,Value] cpTransform cpTransformRotate(cpFloat radians);

	[Static,Value] cpTransform cpTransformRigid([Get="Ptr2cpVect"] pVect translate, cpFloat radians);

	[Static,Value] cpTransform cpTransformRigidInverse([Deref] cpTransform t);

	[Static,Value] cpTransform cpTransformWrap([Deref] cpTransform outer, [Deref] cpTransform inner);

	[Static,Value] cpTransform cpTransformWrapInverse([Deref] cpTransform outer, [Deref] cpTransform inner);

	[Static,Value] cpTransform cpTransformOrtho([Deref] cpBB bb);

	[Static,Value] cpTransform cpTransformBoneScale([Get="Ptr2cpVect"] pVect v0, [Get="Ptr2cpVect"] pVect v1);

	[Static,Value] cpTransform cpTransformAxialScale([Get="Ptr2cpVect"] pVect axis, [Get="Ptr2cpVect"] pVect pivot, cpFloat scale);
};



interface cpMat2x2 {
	void cpMat2x2();
	attribute cpFloat a; 
	attribute cpFloat b;
	attribute cpFloat c;
	attribute cpFloat d;
};


// ---------------------------------------------------------------------------------------------------------
// cpBB.h
//----------------------------------------------------------------------------------------------------------
[Internal="cpBB"]
interface cpBB
{
    attribute cpFloat l;
    attribute cpFloat b;
    attribute cpFloat r;
    attribute cpFloat t;
	
	[Static,Value] cpBB cpBBNew([Const] cpFloat l, [Const] cpFloat b, [Const] cpFloat r, [Const] cpFloat t);
	[Static,Value] cpBB cpBBNewForExtents([Const,Get="Ptr2cpVect"] pVect c, [Const] cpFloat hw, [Const] cpFloat hh);
	[Static,Value] cpBB cpBBNewForCircle([Const,Get="Ptr2cpVect"] pVect p, [Const] cpFloat r);
	[Static] cpBool cpBBIntersects([Const,Deref] cpBB a, [Const,Deref] cpBB b);
	[Static] cpBool cpBBContainsBB([Const,Deref] cpBB bb, [Const,Deref] cpBB other);
	[Static] cpBool cpBBContainsVect([Const,Deref] cpBB bb, [Const,Get="Ptr2cpVect"] pVect v);
	[Static,Value] cpBB cpBBMerge([Const,Deref] cpBB a, [Const,Deref] cpBB b);
	[Static,Value] cpBB cpBBExpand([Const,Deref] cpBB bb, [Const,Get="Ptr2cpVect"] pVect v);
	[Static,Get="cpVect2Ptr"] pVect cpBBCenter([Deref] cpBB bb);
	[Static] cpFloat cpBBArea([Deref] cpBB bb);
	[Static] cpFloat cpBBMergedArea([Deref] cpBB a, [Deref] cpBB b);
	[Static] cpFloat cpBBSegmentQuery([Deref] cpBB bb, [Get="Ptr2cpVect"] pVect a, [Get="Ptr2cpVect"] pVect b);
	[Static] cpBool cpBBIntersectsSegment([Deref] cpBB bb, [Get="Ptr2cpVect"] pVect a, [Get="Ptr2cpVect"] pVect b);
	[Static,Get="cpVect2Ptr"] pVect cpBBClampVect([Const,Deref] cpBB bb, [Const,Get="Ptr2cpVect"] pVect v);
	[Static,Get="cpVect2Ptr"] pVect cpBBWrapVect([Const,Deref] cpBB bb, [Const,Get="Ptr2cpVect"] pVect v);
	[Static,Value] cpBB cpBBOffset([Const,Deref] cpBB bb, [Const,Get="Ptr2cpVect"] pVect v);
};


// ---------------------------------------------------------------------------------------------------------
// Body.h
//----------------------------------------------------------------------------------------------------------
// enum BodyTypeHL {
// 	"CP_BODY_TYPE_DYNAMIC",
// 	"CP_BODY_TYPE_KINEMATIC",
// 	"CP_BODY_TYPE_STATIC"
// };

[Internal="cpBody", Delete="cpBodyFree"]	
interface Body {
	
	[Static, Internal="cpBodyAlloc"] Body alloc();

	[Static, Internal="cpBodyInit"] Body init(Body body, cpFloat mass, cpFloat moment);

	[Static, Internal="cpBodyNew"] Body makeNew(cpFloat mass, cpFloat moment);

	[Static, Internal="cpBodyNewKinematic"] Body newKinematic();

	[Static, Internal="cpBodyNewStatic"] Body newStatic();

	[CObject, Internal="cpBodyDestroy"] void destroy();
	
	[CObject, Internal="cpBodyFree"] void free();

	[CObject, Internal="cpBodyActivate"] void activate();

	//[CObject] void BodyActivateStatic( cpShape filter);

	[CObject, Internal="cpBodySleep"] void sleep();

	[CObject, Internal="cpBodySleepWithGroup"] void sleepWithGroup(Body group);

	[CObject, Internal="cpBodyIsSleeping"] cpBool isSleeping();

	//[CObject] BodyType BodyGetType();

	//[CObject] void BodySetType(BodyType type);

	// [CObject] cpSpace BodyGetSpace();

	[CObject, Internal="cpBodyGetMass"] cpFloat BodyGetMass();

	[CObject, Internal="cpBodySetMass"] void BodySetMass(cpFloat m);

	[CObject, Internal="cpBodyGetMoment"] cpFloat BodyGetMoment();

	[CObject, Internal="cpBodySetMoment"] void BodySetMoment(cpFloat i);

	[CObject, Internal="cpBodyGetPosition", Get="cpVect2Ptr"] pVect getPosition();

	[CObject, Internal="cpBodySetPosition"] void setPosition([Get="Ptr2cpVect"] pVect pos);

	[CObject,Value, Internal="cpBodyGetCenterOfGravity"] Vect BodyGetCenterOfGravity();
	
	[CObject, Internal="cpBodySetCenterOfGravity"] void BodySetCenterOfGravity([Get="Ptr2cpVect"] pVect cog);

	[CObject,Value, Internal="cpBodyGetVelocity"] Vect BodyGetVelocity();

	[CObject, Internal="cpBodySetVelocity"] void BodySetVelocity([Get="Ptr2cpVect"] pVect velocity);

	[CObject,Value, Internal="cpBodyGetForce"] Vect BodyGetForce();

	[CObject, Internal="cpBodySetForce"] void BodySetForce([Get="Ptr2cpVect"] pVect force);

	[CObject, Internal="cpBodyGetAngle"] cpFloat BodyGetAngle();

	[CObject, Internal="cpBodySetAngle"] void BodySetAngle(cpFloat a);

	[CObject, Internal="cpBodyGetAngularVelocity"] cpFloat BodyGetAngularVelocity();

	[CObject, Internal="cpBodySetAngularVelocity"] void BodySetAngularVelocity(cpFloat angularVelocity);

	[CObject, Internal="cpBodyGetTorque"] cpFloat BodyGetTorque();

	[CObject, Internal="cpBodySetTorque"] void BodySetTorque(cpFloat torque);

	[CObject,Value, Internal="cpBodyGetRotation"] Vect BodyGetRotation();

	//[CObject] cpDataPointer BodyGetUserData();

	//[CObject] void BodySetUserData(cpDataPointer userData);

	// [CObject] void BodySetVelocityUpdateFunc(BodyVelocityFunc velocityFunc); // TODO

	// [CObject] void BodySetPositionUpdateFunc(BodyPositionFunc positionFunc); // TODO

	[CObject, Internal="cpBodyUpdateVelocity"] void BodyUpdateVelocity([Get="Ptr2cpVect"] pVect gravity, cpFloat damping, cpFloat dt);
	
	[CObject, Internal="cpBodyUpdatePosition"] void BodyUpdatePosition(cpFloat dt);

	[CObject,Value, Internal="cpBodyLocalToWorld"] Vect BodyLocalToWorld([Const,Get="Ptr2cpVect"] pVect point);

	[CObject,Value, Internal="cpBodyWorldToLocal"] Vect BodyWorldToLocal([Const,Get="Ptr2cpVect"] pVect point);

	[CObject, Internal="cpBodyApplyForceAtWorldPoint"] void BodyApplyForceAtWorldPoint([Get="Ptr2cpVect"] pVect force, [Get="Ptr2cpVect"] pVect point);

	[CObject, Internal="cpBodyApplyForceAtLocalPoint"] void BodyApplyForceAtLocalPoint([Get="Ptr2cpVect"] pVect force, [Get="Ptr2cpVect"] pVect point);

	[CObject, Internal="cpBodyApplyImpulseAtWorldPoint"] void BodyApplyImpulseAtWorldPoint([Get="Ptr2cpVect"] pVect impulse, [Get="Ptr2cpVect"] pVect point);
	
	[CObject, Internal="cpBodyApplyImpulseAtLocalPoint"] void BodyApplyImpulseAtLocalPoint([Get="Ptr2cpVect"] pVect impulse, [Get="Ptr2cpVect"] pVect point);

	[CObject,Value, Internal="cpBodyGetVelocityAtWorldPoint"] Vect BodyGetVelocityAtWorldPoint([Get="Ptr2cpVect"] pVect point);
	
	[CObject,Value, Internal="cpBodyGetVelocityAtLocalPoint"]  Vect BodyGetVelocityAtLocalPoint([Get="Ptr2cpVect"] pVect point);

	[CObject, Internal="cpBodyKineticEnergy"] cpFloat BodyKineticEnergy();

	// TODO
	// [CObject] void BodyEachShape(BodyShapeIteratorFunc func, void *data);

	// [CObject] void BodyEachConstraint(BodyConstraintIteratorFunc func, void *data);

	// [CObject] void BodyEachArbiter(BodyArbiterIteratorFunc func, void *data);
};


// ---------------------------------------------------------------------------------------------------------
// cpShape.h
//----------------------------------------------------------------------------------------------------------

interface cpPointQueryInfo 
{
	void cpPointQueryInfo();
	[Const] attribute Shape shape;
	[Value] attribute Vect point;
	attribute cpFloat distance;
	[Value] attribute Vect gradient;
};

interface cpSegmentQueryInfo {
	void cpSegmentQueryInfo();
	[Const] attribute Shape shape;
	[Value] attribute Vect point;
	[Value] attribute Vect normal;
	attribute cpFloat alpha;
};

interface cpShapeFilter {
	void cpShapeFilter();
	attribute int64 group;
	attribute cpBitmask categories;
	attribute cpBitmask mask;
};

[Internal="cpShape", Delete="cpShapeFree"]
interface Shape
{

	[Static,Value] cpShapeFilter cpShapeFilterNew(cpGroup group, cpBitmask categories, cpBitmask mask);

	[CObject] void cpShapeDestroy();

	[CObject, Internal="cpShapeFree"] void free();

	[CObject,Value] cpBB cpShapeCacheBB();

	[CObject,Value] cpBB cpShapeUpdate([Deref] cpTransform transform);

	[CObject] cpFloat cpShapePointQuery([Get="Ptr2cpVect"] pVect p, cpPointQueryInfo out);

	[CObject] cpBool cpShapeSegmentQuery([Get="Ptr2cpVect"] pVect a, [Get="Ptr2cpVect"] pVect b, cpFloat radius, cpSegmentQueryInfo info);

	[Static,Value] cpContactPointSet cpShapesCollide([Const] Shape a, [Const] Shape b);

	[CObject] Space cpShapeGetSpace();

	[CObject] Body cpShapeGetBody();

	[CObject] void cpShapeSetBody(Body body);

	[CObject] cpFloat cpShapeGetMass();

	[CObject] void cpShapeSetMass(cpFloat mass);

	[CObject] cpFloat cpShapeGetDensity();

	[CObject] void cpShapeSetDensity(cpFloat density);

	[CObject] cpFloat cpShapeGetMoment();

	[CObject] cpFloat cpShapeGetArea();

	[CObject,Get="cpVect2Ptr"] pVect cpShapeGetCenterOfGravity();

	[CObject,Value] cpBB cpShapeGetBB();

	[CObject] cpBool cpShapeGetSensor();

	[CObject] void cpShapeSetSensor(cpBool sensor);

	[CObject, Internal="cpShapeGetElasticity"] cpFloat getElasticity();

	[CObject, Internal="cpShapeSetElasticity"] void setElasticity(cpFloat elasticity);

	[CObject, Internal="cpShapeGetFriction"] cpFloat getFriction();

	[CObject, Internal="cpShapeSetFriction"] void setFriction(cpFloat friction);

	[CObject,Get="cpVect2Ptr"] pVect cpShapeGetSurfaceVelocity();

	[CObject] void cpShapeSetSurfaceVelocity([Get="Ptr2cpVect"] pVect surfaceVelocity);

	[CObject] cpDataPointer cpShapeGetUserData();

	[CObject] void cpShapeSetUserData(cpDataPointer userData);

	// [CObject] cpCollisionType cpShapeGetCollisionType();

	// [CObject] void cpShapeSetCollisionType(cpCollisionType collisionType);

	[CObject,Value] cpShapeFilter cpShapeGetFilter();

	[CObject] void cpShapeSetFilter([Deref] cpShapeFilter filter);
};


[Internal="cpCircleShape", Delete="cpShapeFreeT<cpCircleShape>"]
interface CircleShape
{
	[Static, Internal="cpCircleShapeAlloc"] CircleShape alloc();
	[Static, Internal="cpCircleShapeInit"] CircleShape init(CircleShape circle, Body body, cpFloat radius, [Get="Ptr2cpVect"] pVect offset);
	[Static, Internal="cpCircleShapeNew"] Shape makeNew(Body body, cpFloat radius, [Get="Ptr2cpVect"] pVect offset);
	[Static,Value, Internal="cpCircleShapeGetOffset"] Vect getOffset([Const] Shape shape);
	[Static, Internal="cpCircleShapeGetRadius"] cpFloat getRadius([Const] Shape shape);
};


[Internal="cpSegmentShape", Delete="cpShapeFreeT<cpSegmentShape>"]
interface SegmentShape
{
	[Static,Internal="cpSegmentShapeAlloc"] SegmentShape alloc();

	[CObject,Internal="cpSegmentShapeInit"] SegmentShape init(Body body, [Get="Ptr2cpVect"] pVect a, [Get="Ptr2cpVect"] pVect b, cpFloat radius);

	[Static,Internal="cpSegmentShapeNew"] Shape newSegmentShape(Body body, [Get="Ptr2cpVect"] pVect a, [Get="Ptr2cpVect"] pVect b, cpFloat radius);

	[Static,Internal="cpSegmentShapeSetNeighbors"] void setNeighbors(Shape shape, [Get="Ptr2cpVect"] pVect prev, [Get="Ptr2cpVect"] pVect next);

	[Static,Value,Internal="cpSegmentShapeGetA"] Vect getA([Const] Shape shape);

	[Static,Value,Internal="cpSegmentShapeGetB"] Vect getB([Const] Shape shape);

	[Static,Value,Internal="cpSegmentShapeGetNormal"] Vect getNormal([Const] Shape shape);

	[Static,Internal="cpSegmentShapeGetRadius"] cpFloat getRadius([Const] Shape shape);
};

// ---------------------------------------------------------------------------------------------------------
// cpSpace.h
//----------------------------------------------------------------------------------------------------------

[Internal="cpSpace", Delete="cpSpaceFree"]
interface Space
{
	[Static, Internal="cpSpaceInit"] Space init(Space space);

	[Static, Internal="cpSpaceNew"] Space makeNew();

	[CObject, Internal="cpSpaceDestroy"] void destroy();

	[CObject, Internal="cpSpaceFree"] void free();

	[CObject, Internal="cpSpaceGetIterations"] int getIterations();

	[CObject, Internal="cpSpaceSetIterations"] void setIterations(int iterations);

	[CObject,Value, Internal="cpSpaceGetGravity"] Vect cpSpaceGetGravity();

	[CObject, Internal="cpSpaceSetGravity"] void setGravity([Get="Ptr2cpVect"] pVect gravity);

	[CObject, Internal="cpSpaceGetDamping"] cpFloat getDamping();

	[CObject, Internal="cpSpaceSetDamping"] void setDamping(cpFloat damping);

	[CObject, Internal="cpSpaceGetIdleSpeedThreshold"] cpFloat getIdleSpeedThreshold();

	[CObject, Internal="cpSpaceSetIdleSpeedThreshold"] void setIdleSpeedThreshold(cpFloat idleSpeedThreshold);

	[CObject, Internal="cpSpaceGetSleepTimeThreshold"] cpFloat getSleepTimeThreshold();

	[CObject, Internal="cpSpaceSetSleepTimeThreshold"] void setSleepTimeThreshold(cpFloat sleepTimeThreshold);

	[CObject, Internal="cpSpaceGetCollisionSlop"] cpFloat getCollisionSlop();

	[CObject, Internal="cpSpaceSetCollisionSlop"] void setCollisionSlop(cpFloat collisionSlop);

	[CObject, Internal="cpSpaceGetCollisionBias"] cpFloat getCollisionBias();

	[CObject, Internal="cpSpaceSetCollisionBias"] void setCollisionBias(cpFloat collisionBias);

	// [CObject] cpTimestamp cpSpaceGetCollisionPersistence();

	// [CObject] void cpSpaceSetCollisionPersistence(cpTimestamp collisionPersistence);

	[CObject, Internal="cpSpaceGetUserData"] cpDataPointer getUserData();

	[CObject, Internal="cpSpaceSetUserData"] void setUserData(cpDataPointer userData);

	[CObject, Internal="cpSpaceGetStaticBody"] Body getStaticBody();

	[CObject, Internal="cpSpaceGetCurrentTimeStep"] cpFloat getCurrentTimeStep();

	[CObject, Internal="cpSpaceIsLocked"] cpBool isLocked();

	// [CObject] cpCollisionHandler *cpSpaceAddDefaultCollisionHandler();

	// [CObject] cpCollisionHandler *cpSpaceAddCollisionHandler(cpCollisionType a, cpCollisionType b);

	// [CObject] cpCollisionHandler *cpSpaceAddWildcardHandler(cpCollisionType type);

	[CObject, Internal="cpSpaceAddShape"] void addShape(Shape shape); // README. I had to replace the original functions because each call was duplicating the space.

	[CObject, Internal="cpSpaceAddBody"] void addBody(Body body); // README. I had to replace the original functions because each call was duplicating the space.

	[CObject] Constraint cpSpaceAddConstraint(Constraint constraint);

	[CObject] void cpSpaceRemoveShape(Shape shape);

	[CObject] void cpSpaceRemoveBody(Body body);

	[CObject] void cpSpaceRemoveConstraint(Constraint constraint);

	[CObject] cpBool cpSpaceContainsShape(Shape shape);

	[CObject] cpBool cpSpaceContainsBody(Body body);

	[CObject] cpBool cpSpaceContainsConstraint(Constraint constraint);

	// [CObject] cpBool cpSpaceAddPostStepCallback(cpPostStepFunc func, void *key, void *data);

	// [CObject] void cpSpacePointQuery(Vect point, cpFloat maxDistance, cpShapeFilter filter, cpSpacePointQueryFunc func, void *data);

	// [CObject] cpShape cpSpacePointQueryNearest(Vect point, cpFloat maxDistance, cpShapeFilter filter, cpPointQueryInfo *out);

	// [CObject] void cpSpaceSegmentQuery(Vect start, Vect end, cpFloat radius, cpShapeFilter filter, cpSpaceSegmentQueryFunc func, void *data);

	[CObject] Shape cpSpaceSegmentQueryFirst([Get="Ptr2cpVect"] pVect start, [Get="Ptr2cpVect"] pVect end, cpFloat radius, [Deref] cpShapeFilter filter, cpSegmentQueryInfo out);
	
	[CObject] Shape cpSpaceSegmentQueryFirstNoFilter([Get="Ptr2cpVect"] pVect start, [Get="Ptr2cpVect"] pVect end, cpFloat radius, cpSegmentQueryInfo out);

	// [CObject] void cpSpaceBBQuery(cpBB bb, cpShapeFilter filter, cpSpaceBBQueryFunc func, void *data);

	// [CObject] cpBool cpSpaceShapeQuery(cpShape shape, cpSpaceShapeQueryFunc func, void *data);

	// [CObject] void cpSpaceEachBody(cpSpaceBodyIteratorFunc func, void *data);

	// [CObject] void cpSpaceEachShape(cpSpaceShapeIteratorFunc func, void *data);

	// [CObject] void cpSpaceEachConstraint(cpSpaceConstraintIteratorFunc func, void *data);

	[CObject] void cpSpaceReindexStatic();

	[CObject] void cpSpaceReindexShape(Shape shape);

	[CObject] void cpSpaceReindexShapesForBody(Body body);

	[CObject] void cpSpaceUseSpatialHash(cpFloat dim, int count);

	[CObject, Internal="cpSpaceStep"] void step(cpFloat dt);
};


// ---------------------------------------------------------------------------------------------------------
// cpArbiter.h
//----------------------------------------------------------------------------------------------------------
interface cpContactPointSet {
	
};


[NoDelete]
interface cpArbiter
{
	[CObject] cpFloat cpArbiterGetRestitution();

	[CObject] void cpArbiterSetRestitution(cpFloat restitution);

	[CObject] cpFloat cpArbiterGetFriction();

	[CObject] void cpArbiterSetFriction(cpFloat friction);

	[CObject,Get="cpVect2Ptr"] pVect cpArbiterGetSurfaceVelocity();

	[CObject] void cpArbiterSetSurfaceVelocity([Get="Ptr2cpVect"] pVect vr);

	[CObject] cpDataPointer cpArbiterGetUserData();

	[CObject] void cpArbiterSetUserData(cpDataPointer userData);

	[CObject,Get="cpVect2Ptr"] pVect cpArbiterTotalImpulse();

	[CObject] cpFloat cpArbiterTotalKE();

	[CObject] cpBool cpArbiterIgnore();

	// CP_EXPORT void cpArbiterGetShapes(const cpArbiter *arb, cpShape **a, cpShape **b);

	// CP_EXPORT void cpArbiterGetBodies(const cpArbiter *arb, Body **a, Body **b);

	[CObject,Value] cpContactPointSet cpArbiterGetContactPointSet();

	[CObject] void cpArbiterSetContactPointSet(cpContactPointSet set);

	[CObject] cpBool cpArbiterIsFirstContact();

	[CObject] cpBool cpArbiterIsRemoval();

	[CObject] int cpArbiterGetCount();

	[CObject,Get="cpVect2Ptr"] pVect cpArbiterGetNormal();

	[CObject,Get="cpVect2Ptr"] pVect cpArbiterGetPointA(int i);

	[CObject,Get="cpVect2Ptr"] pVect cpArbiterGetPointB(int i);

	[CObject] cpFloat cpArbiterGetDepth(int i);

	[CObject] cpBool cpArbiterCallWildcardBeginA(Space space);

	[CObject] cpBool cpArbiterCallWildcardBeginB(Space space);

	[CObject] cpBool cpArbiterCallWildcardPreSolveA(Space space);

	[CObject] cpBool cpArbiterCallWildcardPreSolveB(Space space);

	[CObject] void cpArbiterCallWildcardPostSolveA(Space space);

	[CObject] void cpArbiterCallWildcardPostSolveB(Space space);

	[CObject] void cpArbiterCallWildcardSeparateA(Space space);

	[CObject] void cpArbiterCallWildcardSeparateB(Space space);
};


// ---------------------------------------------------------------------------------------------------------
// cpConstraint.h
//----------------------------------------------------------------------------------------------------------

[Internal="cpConstraint", Delete="cpConstraintFree"]
interface Constraint
{
	[CObject, Internal="cpConstraintDestroy"] void destroy();

	[CObject, Internal="cpConstraintFree"] void free();

	[CObject, Internal="cpConstraintGetSpace" ] Space getSpace();

	[CObject, Internal="cpConstraintGetBodyA"] Body getBodyA();

	[CObject, Internal="cpConstraintGetBodyB"] Body getBodyB();

	[CObject, Internal="cpConstraintGetMaxForce"] cpFloat getMaxForce();
	
	[CObject, Internal="cpConstraintSetMaxForce"] void setMaxForce(cpFloat maxForce);

	[CObject, Internal="cpConstraintGetErrorBias"] cpFloat getErrorBias();

	[CObject, Internal="cpConstraintSetErrorBias"] void setErrorBias(cpFloat errorBias);

	[CObject, Internal="cpConstraintGetMaxBias"] cpFloat getMaxBias();

	[CObject, Internal="cpConstraintSetMaxBias"] void setMaxBias(cpFloat maxBias);

	[CObject, Internal="cpConstraintGetCollideBodies"] cpBool getCollideBodies();

	[CObject] void cpConstraintSetCollideBodies(cpBool collideBodies);

	//[CObject] cpConstraintPreSolveFunc cpConstraintGetPreSolveFunc();

	//[CObject] void cpConstraintSetPreSolveFunc(cpConstraintPreSolveFunc preSolveFunc);

	//[CObject] cpConstraintPostSolveFunc cpConstraintGetPostSolveFunc();

	//[CObject] void cpConstraintSetPostSolveFunc(cpConstraintPostSolveFunc postSolveFunc);

	[CObject] cpDataPointer cpConstraintGetUserData();

	[CObject] void cpConstraintSetUserData(cpDataPointer userData);

	[CObject] cpFloat cpConstraintGetImpulse();
};


// ---------------------------------------------------------------------------------------------------------
// cpDampedRotarySpring.h
//----------------------------------------------------------------------------------------------------------
[NoDelete]
interface cpDampedRotarySpring
{
	[Static] cpBool cpConstraintIsDampedRotarySpring([Const] Constraint constraint);

	[Const,Static] cpDampedRotarySpring cpDampedRotarySpringAlloc();

	[Const,Static] cpDampedRotarySpring cpDampedRotarySpringInit(cpDampedRotarySpring joint, 
			Body a, Body b, cpFloat restAngle, cpFloat stiffness, cpFloat damping);

	[Static] Constraint cpDampedRotarySpringNew(Body a, Body b, cpFloat restAngle, 
			cpFloat stiffness, cpFloat damping);

	[Static] cpFloat cpDampedRotarySpringGetRestAngle([Const] Constraint constraint);

	[Static] void cpDampedRotarySpringSetRestAngle(Constraint constraint, cpFloat restAngle);

	[Static] cpFloat cpDampedRotarySpringGetStiffness([Const] Constraint constraint);

	[Static] void cpDampedRotarySpringSetStiffness([Const] Constraint constraint, cpFloat stiffness);

	[Static] cpFloat cpDampedRotarySpringGetDamping([Const] Constraint constraint);

	[Static] void cpDampedRotarySpringSetDamping(Constraint constraint, cpFloat damping);

	// [Static] cpDampedRotarySpringTorqueFunc cpDampedRotarySpringGetSpringTorqueFunc(const Constraint *constraint);

	//[Static] void cpDampedRotarySpringSetSpringTorqueFunc(Constraint *constraint, cpDampedRotarySpringTorqueFunc springTorqueFunc);
};


// ---------------------------------------------------------------------------------------------------------
// cpDampedSpring.h
//----------------------------------------------------------------------------------------------------------
[Delete="cpConstraintFreeT<cpDampedSpring>"]
interface cpDampedSpring
{
	[Static] cpBool cpConstraintIsDampedSpring([Const] Constraint constraint);

	// The constraint owns these allocations
	[Static] cpDampedSpring cpDampedSpringAlloc();

	[Static] cpDampedSpring cpDampedSpringInit(cpDampedSpring joint, Body a, Body b, 
			[Get="Ptr2cpVect"] pVect anchorA, [Get="Ptr2cpVect"] pVect anchorB, cpFloat restLength, cpFloat stiffness, cpFloat damping);

	[Static] Constraint cpDampedSpringNew(Body a, Body b, [Get="Ptr2cpVect"] pVect anchorA, [Get="Ptr2cpVect"] pVect anchorB, 
			cpFloat restLength, cpFloat stiffness, cpFloat damping);

	[Static,Get="cpVect2Ptr"] pVect cpDampedSpringGetAnchorA([Const] Constraint constraint);

	[Static] void cpDampedSpringSetAnchorA(Constraint constraint, [Get="Ptr2cpVect"] pVect anchorA);

	[Static,Get="cpVect2Ptr"] pVect cpDampedSpringGetAnchorB([Const] Constraint constraint);

	[Static] void cpDampedSpringSetAnchorB(Constraint constraint, [Get="Ptr2cpVect"] pVect anchorB);

	[Static] cpFloat cpDampedSpringGetRestLength([Const] Constraint constraint);

	[Static] void cpDampedSpringSetRestLength(Constraint constraint, cpFloat restLength);

	[Static] cpFloat cpDampedSpringGetStiffness([Const] Constraint constraint);

	[Static] void cpDampedSpringSetStiffness(Constraint constraint, cpFloat stiffness);

	[Static] cpFloat cpDampedSpringGetDamping([Const] Constraint constraint);

	[Static] void cpDampedSpringSetDamping(Constraint constraint, cpFloat damping);

	// [Static] cpDampedSpringForceFunc cpDampedSpringGetSpringForceFunc(const Constraint *constraint);

	// [Static] void cpDampedSpringSetSpringForceFunc(Constraint *constraint, cpDampedSpringForceFunc springForceFunc);
};


// ---------------------------------------------------------------------------------------------------------
// cpGearJoint.h
//----------------------------------------------------------------------------------------------------------
[Delete="cpConstraintFreeT<cpGearJoint>"]
interface cpGearJoint
{
	[Static] cpBool cpConstraintIsGearJoint([Const]  Constraint constraint);

	[Static] cpGearJoint cpGearJointAlloc();

	[Static] cpGearJoint cpGearJointInit(cpGearJoint joint, Body a, Body b, cpFloat phase, cpFloat ratio);

	[Static] Constraint cpGearJointNew(Body a, Body b, cpFloat phase, cpFloat ratio);

	[Static] cpFloat cpGearJointGetPhase([Const] Constraint constraint);

	[Static] void cpGearJointSetPhase(Constraint constraint, cpFloat phase);

	[Static] cpFloat cpGearJointGetRatio([Const] Constraint constraint);

	[Static] void cpGearJointSetRatio(Constraint constraint, cpFloat ratio);
};


// ---------------------------------------------------------------------------------------------------------
// cpSimpleMotor.h
//----------------------------------------------------------------------------------------------------------

[Delete="cpConstraintFreeT<cpSimpleMotor>"]
interface cpSimpleMotor
{
	[Static] cpBool cpConstraintIsSimpleMotor([Const] Constraint constraint);

	[Static] cpSimpleMotor cpSimpleMotorAlloc();

	[Static] cpSimpleMotor cpSimpleMotorInit(cpSimpleMotor joint, Body a, Body b, cpFloat rate);

	[Static] Constraint cpSimpleMotorNew(Body a, Body b, cpFloat rate);

	[Static] cpFloat cpSimpleMotorGetRate([Const] Constraint constraint);

	[Static] void cpSimpleMotorSetRate(Constraint constraint, cpFloat rate);
};


// ---------------------------------------------------------------------------------------------------------
// cpGrooveJoint.h
//----------------------------------------------------------------------------------------------------------
[Delete="cpConstraintFreeT<cpGrooveJoint>"]
interface cpGrooveJoint
{
	[Static] cpBool cpConstraintIsGrooveJoint([Const] Constraint constraint);

	[Static] cpGrooveJoint cpGrooveJointAlloc();

	[Static] cpGrooveJoint cpGrooveJointInit(cpGrooveJoint joint, Body a, Body b, [Get="Ptr2cpVect"] pVect groove_a, 
			[Get="Ptr2cpVect"] pVect groove_b, [Get="Ptr2cpVect"] pVect anchorB);

	[Static] Constraint cpGrooveJointNew(Body a, Body b, [Get="Ptr2cpVect"] pVect groove_a, [Get="Ptr2cpVect"] pVect groove_b, 
			[Get="Ptr2cpVect"] pVect anchorB);

	[Static,Get="cpVect2Ptr"] pVect cpGrooveJointGetGrooveA([Const] Constraint constraint);

	[Static] void cpGrooveJointSetGrooveA(Constraint constraint, [Get="Ptr2cpVect"] pVect grooveA);

	[Static,Get="cpVect2Ptr"] pVect cpGrooveJointGetGrooveB([Const] Constraint constraint);

	[Static] void cpGrooveJointSetGrooveB(Constraint constraint, [Get="Ptr2cpVect"] pVect grooveB);

	[Static,Get="cpVect2Ptr"] pVect cpGrooveJointGetAnchorB([Const] Constraint constraint);

	[Static] void cpGrooveJointSetAnchorB(Constraint constraint, [Get="Ptr2cpVect"] pVect anchorB);
};


// ---------------------------------------------------------------------------------------------------------
// cpHastySpace.h
//----------------------------------------------------------------------------------------------------------

[Internal="cpSpace", Delete="cpHastySpaceFree"]
interface cpHastySpace
{
	[Static,Internal="cpHastySpaceNew"] Space makeNew();
	[Static,Internal="cpHastySpaceFree"] void free(Space space);
	[Static,Internal="cpHastySpaceSetThreads"] void setThreads(Space space, uint threads);
	[Static,Internal="cpHastySpaceGetThreads"] uint getThreads(Space space);
	[Static,Internal="cpHastySpaceStep"] void step(Space space, cpFloat dt);
};


// ---------------------------------------------------------------------------------------------------------
// cpHastySpace.h
//----------------------------------------------------------------------------------------------------------
[Delete="cpConstraintFreeT<cpPinJoint>"]
interface cpPinJoint
{	
	[Static] cpBool cpConstraintIsPinJoint([Const] Constraint constraint);

	[Static] cpPinJoint cpPinJointAlloc();

	[Static] cpPinJoint cpPinJointInit(cpPinJoint joint, Body a, Body b, 
				[Get="Ptr2cpVect"] pVect anchorA, [Get="Ptr2cpVect"] pVect anchorB);

	[Static] Constraint cpPinJointNew(Body a, Body b, [Get="Ptr2cpVect"] pVect anchorA, [Get="Ptr2cpVect"] pVect anchorB);

	[Static,Get="cpVect2Ptr"] pVect cpPinJointGetAnchorA([Const] Constraint constraint);

	[Static] void cpPinJointSetAnchorA(Constraint constraint, [Get="Ptr2cpVect"] pVect anchorA);

	[Static,Get="cpVect2Ptr"] pVect cpPinJointGetAnchorB([Const] Constraint constraint);

	[Static] void cpPinJointSetAnchorB(Constraint constraint, [Get="Ptr2cpVect"] pVect anchorB);

	[Static] cpFloat cpPinJointGetDist([Const] Constraint constraint);

	[Static] void cpPinJointSetDist(Constraint constraint, cpFloat dist);
};


// ---------------------------------------------------------------------------------------------------------
// cpPivotJoint.h
//----------------------------------------------------------------------------------------------------------
[Delete="cpConstraintFreeT<cpPivotJoint>"]
interface cpPivotJoint
{
	[Static] cpBool cpConstraintIsPivotJoint([Const] Constraint constraint);

	[Static] cpPivotJoint cpPivotJointAlloc();

	[Static] cpPivotJoint cpPivotJointInit(cpPivotJoint joint, Body a, Body b, [Get="Ptr2cpVect"] pVect anchorA, [Get="Ptr2cpVect"] pVect anchorB);

	[Static] Constraint cpPivotJointNew(Body a, Body b, [Get="Ptr2cpVect"] pVect pivot);

	[Static] Constraint cpPivotJointNew2(Body a, Body b, [Get="Ptr2cpVect"] pVect anchorA, [Get="Ptr2cpVect"] pVect anchorB);

	[Static,Get="cpVect2Ptr"] pVect cpPivotJointGetAnchorA([Const] Constraint constraint);

	[Static] void cpPivotJointSetAnchorA(Constraint constraint, [Get="Ptr2cpVect"] pVect anchorA);

	[Static,Get="cpVect2Ptr"] pVect cpPivotJointGetAnchorB([Const] Constraint constraint);

	[Static] void cpPivotJointSetAnchorB(Constraint constraint, [Get="Ptr2cpVect"] pVect anchorB);
};


// ---------------------------------------------------------------------------------------------------------
// cpPolyline.h
//----------------------------------------------------------------------------------------------------------
[Delete="cpPolylineFree"]
interface cpPolyline
{
	[Static,Internal="cpPolylineFree"] void free(cpPolyline line);

	[Static] cpBool cpPolylineIsClosed(cpPolyline line);

	[Static] cpPolyline cpPolylineSimplifyCurves(cpPolyline line, cpFloat tol);

	[Static] cpPolyline cpPolylineSimplifyVertexes(cpPolyline line, cpFloat tol);

	[Static] cpPolyline cpPolylineToConvexHull(cpPolyline line, cpFloat tol);
};


interface cpPolylineSet
{
	[Static] cpPolylineSet cpPolylineSetAlloc();

	[Static] cpPolylineSet cpPolylineSetInit(cpPolylineSet set);

	[Static] cpPolylineSet cpPolylineSetNew();

	[Static] void cpPolylineSetDestroy(cpPolylineSet set, cpBool freePolylines);

	[Static] void cpPolylineSetFree(cpPolylineSet set, cpBool freePolylines);

	[Static] void cpPolylineSetCollectSegment([Get="Ptr2cpVect"] pVect v0, [Get="Ptr2cpVect"] pVect v1, cpPolylineSet lines);

	[Static] cpPolylineSet cpPolylineConvexDecomposition(cpPolyline line, cpFloat tol);
};


// ---------------------------------------------------------------------------------------------------------
// cpPolyShape.h
//----------------------------------------------------------------------------------------------------------
[Delete="cpShapeFreeT<cpPolyShape>"]
interface cpPolyShape
{
	[Static] cpPolyShape cpPolyShapeAlloc();

	[Static] cpPolyShape cpPolyShapeInit(cpPolyShape poly, Body body, int count, 
				[Const,Cast="cpVect*"] double[] verts, [Deref] cpTransform transform, cpFloat radius);

	// TODO THIS IS GOING TO FAIL
	[Static] cpPolyShape cpPolyShapeInitRaw(cpPolyShape poly, Body body, int count, [Const,Cast="cpVect*"] double[] verts, cpFloat radius);

	// TODO THIS IS GOING TO FAIL
	[Static] Shape cpPolyShapeNew(Body body, int count, [Const,Cast="cpVect*"] double[] verts, [Deref] cpTransform transform, cpFloat radius);

	// TODO THIS IS GOING TO FAIL
	[Static] Shape cpPolyShapeNewRaw(Body body, int count, [Const,Cast="cpVect*"] double[] verts, cpFloat radius);

	[Static] cpPolyShape cpBoxShapeInit(cpPolyShape poly, Body body, cpFloat width, cpFloat height, cpFloat radius);

	[Static] cpPolyShape cpBoxShapeInit2(cpPolyShape poly, Body body, [Deref] cpBB box, cpFloat radius);

	[Static] Shape cpBoxShapeNew(Body body, cpFloat width, cpFloat height, cpFloat radius);

	[Static] Shape cpBoxShapeNew2(Body body, [Deref] cpBB box, cpFloat radius);

	[Static] int cpPolyShapeGetCount([Const] Shape shape);

	[Static,Get="cpVect2Ptr"] pVect cpPolyShapeGetVert([Const] Shape shape, int index);

	[Static] cpFloat cpPolyShapeGetRadius([Const] Shape shape);
};


// ---------------------------------------------------------------------------------------------------------
// cpRatchetJoint.h
//----------------------------------------------------------------------------------------------------------
[Delete="cpShapeFreeT<cpRatchetJoint>"]
interface cpRatchetJoint
{
	[Static] cpBool cpConstraintIsRatchetJoint([Const] Constraint constraint);

	[Static] cpRatchetJoint cpRatchetJointAlloc();

	[Static] cpRatchetJoint cpRatchetJointInit(cpRatchetJoint joint, Body a, Body b, cpFloat phase, cpFloat ratchet);

	[Static] Constraint cpRatchetJointNew(Body a, Body b, cpFloat phase, cpFloat ratchet);

	[Static] cpFloat cpRatchetJointGetAngle([Const] Constraint constraint);

	[Static] void cpRatchetJointSetAngle(Constraint constraint, cpFloat angle);

	[Static] cpFloat cpRatchetJointGetPhase([Const] Constraint constraint);

	[Static] void cpRatchetJointSetPhase(Constraint constraint, cpFloat phase);

	[Static] cpFloat cpRatchetJointGetRatchet([Const] Constraint constraint);

	[Static] void cpRatchetJointSetRatchet(Constraint constraint, cpFloat ratchet);
};


// ---------------------------------------------------------------------------------------------------------
// cpRotaryLimitJoint
//----------------------------------------------------------------------------------------------------------
[Delete="cpShapeFreeT<cpRotaryLimitJoint>"]
interface cpRotaryLimitJoint
{
	[Static] cpBool cpConstraintIsRotaryLimitJoint([Const] Constraint constraint);

	[Static] cpRotaryLimitJoint cpRotaryLimitJointAlloc();

	[Static] cpRotaryLimitJoint cpRotaryLimitJointInit(cpRotaryLimitJoint joint, Body a, Body b, cpFloat min, cpFloat max);
	
	[Static] Constraint cpRotaryLimitJointNew(Body a, Body b, cpFloat min, cpFloat max);

	[Static] cpFloat cpRotaryLimitJointGetMin([Const] Constraint constraint);

	[Static] void cpRotaryLimitJointSetMin(Constraint constraint, cpFloat min);

	[Static] cpFloat cpRotaryLimitJointGetMax([Const] Constraint constraint);

	[Static] void cpRotaryLimitJointSetMax(Constraint constraint, cpFloat max);
};


// ---------------------------------------------------------------------------------------------------------
// cpSlideJoint
//----------------------------------------------------------------------------------------------------------
[Internal="cpSlideJoint", Delete="cpShapeFreeT<cpSlideJoint>"]
interface SlideJoint
{
	[Static] cpBool cpConstraintIsSlideJoint([Const] Constraint constraint);

	[Static] SlideJoint cpSlideJointAlloc();

	[Static] SlideJoint cpSlideJointInit(SlideJoint joint, Body a, Body b, 
				[Get="Ptr2cpVect"] pVect anchorA, [Get="Ptr2cpVect"] pVect anchorB, cpFloat min, cpFloat max);

	[Static] Constraint cpSlideJointNew(Body a, Body b, [Get="Ptr2cpVect"] pVect anchorA, [Get="Ptr2cpVect"] pVect anchorB, 
				cpFloat min, cpFloat max);

	[Static,Get="cpVect2Ptr"] pVect cpSlideJointGetAnchorA([Const] Constraint constraint);

	[Static] void cpSlideJointSetAnchorA(Constraint constraint, [Get="Ptr2cpVect"] pVect anchorA);

	[Static,Get="cpVect2Ptr"] pVect cpSlideJointGetAnchorB([Const] Constraint constraint);

	[Static] void cpSlideJointSetAnchorB(Constraint constraint, [Get="Ptr2cpVect"] pVect anchorB);

	[Static] cpFloat cpSlideJointGetMin([Const] Constraint constraint);

	[Static] void cpSlideJointSetMin(Constraint constraint, cpFloat min);

	[Static] cpFloat cpSlideJointGetMax([Const] Constraint constraint);

	[Static] void cpSlideJointSetMax(Constraint constraint, cpFloat max);
};


// ---------------------------------------------------------------------------------------------------------
// cpSpaceHash.c
//----------------------------------------------------------------------------------------------------------

[Delete="cpSpatialIndexFreeT<cpSpaceHash>"]
interface cpSpaceHash {
	[Static, Internal="cpSpaceHashAlloc"] cpSpaceHash alloc();

	// Deadly callbacks
//	[CObject, Internal="cpSpaceHashInit"] SpatialIndex init(cpFloat celldim, int numcells, cpSpatialIndexBBFunc bbfunc, SpatialIndex staticIndex);
	// CP_EXPORT cpSpatialIndex* cpSpaceHashNew(cpFloat celldim, int cells, cpSpatialIndexBBFunc bbfunc, cpSpatialIndex *staticIndex);

};


// ---------------------------------------------------------------------------------------------------------
// cpBBTree.c
//----------------------------------------------------------------------------------------------------------
[Delete="cpSpatialIndexFreeT<cpBBTree>"]
interface cpBBTree {
	[Static,Internal="cpBBTreeAlloc"] cpBBTree alloc();
// CP_EXPORT cpSpatialIndex* cpBBTreeInit(cpBBTree *tree, cpSpatialIndexBBFunc bbfunc, cpSpatialIndex *staticIndex);

// CP_EXPORT cpSpatialIndex* cpBBTreeNew(cpSpatialIndexBBFunc bbfunc, cpSpatialIndex *staticIndex);

	[Static] void cpBBTreeOptimize(SpatialIndex index);

// CP_EXPORT void cpBBTreeSetVelocityFunc(cpSpatialIndex *index, cpBBTreeVelocityFunc func);

};


// ---------------------------------------------------------------------------------------------------------
// cpSpatialIndex.h
//----------------------------------------------------------------------------------------------------------
typedef cpHashValue uint;

//interface cpSpatialIndexClass {};

[Internal="cpSpatialIndex", Delete="cpSpatialIndexFree"]
interface SpatialIndex
{
	


	[Static] void cpSpaceHashResize(cpSpaceHash hash, cpFloat celldim, int numcells);




	// [Static] cpSweep1D cpSweep1DAlloc();

// CP_EXPORT cpSpatialIndex* cpSweep1DInit(cpSweep1D *sweep, cpSpatialIndexBBFunc bbfunc, cpSpatialIndex *staticIndex);

// CP_EXPORT cpSpatialIndex* cpSweep1DNew(cpSpatialIndexBBFunc bbfunc, cpSpatialIndex *staticIndex);

	// Should likely not be publically available [RC]
	[CObject, Internal="cpSpatialIndexFree"] void free();

	// [Static] void cpSpatialIndexCollideStatic(cpSpatialIndex dynamicIndex, cpSpatialIndex staticIndex, 
	// 		cpSpatialIndexQueryFunc func, VoidPtr data);

	[CObject] void cpSpatialIndexDestroy();

	[CObject] int cpSpatialIndexCount();

	// [CObject] void cpSpatialIndexEach(cpSpatialIndexIteratorFunc func, VoidPtr data)

	[CObject] cpBool cpSpatialIndexContains(VoidPtr obj, cpHashValue hashid);

	[CObject] void cpSpatialIndexInsert(VoidPtr obj, cpHashValue hashid);

	[CObject] void cpSpatialIndexRemove(VoidPtr obj, cpHashValue hashid);

	[CObject] void cpSpatialIndexReindex();

	[CObject] void cpSpatialIndexReindexObject(VoidPtr obj, cpHashValue hashid);

// static inline void cpSpatialIndexQuery(cpSpatialIndex *index, void *obj, cpBB bb, 
				// cpSpatialIndexQueryFunc func, void *data)

// static inline void cpSpatialIndexSegmentQuery(cpSpatialIndex *index, void *obj, Vect a, Vect b, 
				// cpFloat t_exit, cpSpatialIndexSegmentQueryFunc func, void *data)

// static inline void cpSpatialIndexReindexQuery(cpSpatialIndex *index, cpSpatialIndexQueryFunc func, void *data)
};


// ---------------------------------------------------------------------------------------------------------
// chipmunk.h + cpRobust.h
//----------------------------------------------------------------------------------------------------------
[NoDelete]
interface Math 
{
	[Static, Internal="cpMomentForCircle"] cpFloat momentForCircle(cpFloat m, cpFloat r1, cpFloat r2, [Get="Ptr2cpVect"] pVect offset);

	[Static, Internal="cpAreaForCircle"] cpFloat areaForCircle(cpFloat r1, cpFloat r2);
	
	[Static, Internal="cpMomentForSegment"] cpFloat momentForSegment(cpFloat m, [Deref,Cast="cpVect*"] Vect a, [Get="Ptr2cpVect"] pVect b, cpFloat radius);
	
	[Static, Internal="cpMomentForPoly"] cpFloat momentForPoly( cpFloat m, int count, [Const,Cast="cpVect*"] double[] verts, 
							[Get="Ptr2cpVect"] pVect offset, cpFloat radius);

	[Static, Internal="cpAreaForSegment"] cpFloat areaForSegment([Get="Ptr2cpVect"] pVect a, [Get="Ptr2cpVect"] pVect b, cpFloat radius);

	[Static, Internal="cpAreaForPoly"] cpFloat areaForPoly([Const] int count, [Const,Cast="cpVect*"] double[] verts, cpFloat radius);

	[Static,Value, Internal="cpCentroidForPoly"] Vect centroidForPoly([Const] int count, [Cast="cpVect*"] double[] verts);

	[Static, Internal="cpMomentForBox"] cpFloat momentForBox(cpFloat m, cpFloat width, cpFloat height);

	[Static] cpFloat cpMomentForBox2(cpFloat m, [Deref] cpBB box);

	[Static] int cpConvexHull(int count,  [Const,Cast="cpVect*"] double[] verts, 
							[Cast="cpVect*"] double[] result, int[] first, cpFloat tol);

	[Static,Get="cpVect2Ptr"] pVect cpClosetPointOnSegment( [Get="Ptr2cpVect"] pVect p, 
							 [Get="Ptr2cpVect"] pVect a, [Get="Ptr2cpVect"] pVect b);

	// cpRobust.h
	[Static] cpBool cpCheckPointGreater([Const,Get="Ptr2cpVect"] pVect a, [Const,Get="Ptr2cpVect"] pVect b, [Const,Get="Ptr2cpVect"] pVect c);

	[Static] cpBool cpCheckAxis([Get="Ptr2cpVect"] pVect v0, [Get="Ptr2cpVect"] pVect v1, [Get="Ptr2cpVect"] pVect p, [Get="Ptr2cpVect"] pVect n);
};
